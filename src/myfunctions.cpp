#include "myfunctions.h"

namespace luke
{

/* ----- helper functions ----- */

void print_vec(std::vector<bool> v, std::string name) {
  std::cout << name << ": { ";
  if (v.size() == 0) {
    std::cout << "}\n";
    return;
  }
  for (int i = 0; i < v.size() - 1; i++) {
    std::cout << v[i] << " ";
  }
  std::cout << v[v.size() - 1] << " }\n";
}
void print_vec(std::vector<int> v, std::string name) {
  std::cout << name << ": { ";
  if (v.size() == 0) {
    std::cout << "}\n";
    return;
  }
  for (int i = 0; i < v.size() - 1; i++) {
    std::cout << v[i] << ", ";
  }
  std::cout << v[v.size() - 1] << " }\n";
}
void print_vec(std::vector<mjtNum> v, std::string name) {
  std::cout << name << ": { ";
  if (v.size() == 0) {
    std::cout << "}\n";
    return;
  }
  // cast mjtNum to float32 and show to 3dp
  for (int i = 0; i < v.size() - 1; i++) {
    printf("%.3f, ", float(v[i]));
  }
  printf("%.3f }\n", float(v[v.size() - 1]));
}
void print_vec(std::vector<gfloat> v, std::string name) {
  std::cout << name << ": { ";
  if (v.size() == 0) {
    std::cout << "}\n";
    return;
  }
  // cast mjtNum to float32 and show to 3dp
  for (int i = 0; i < v.size() - 1; i++) {
    printf("%.3f, ", float(v[i]));
  }
  printf("%.3f }\n", float(v[v.size() - 1]));
}
void print_vec(std::vector<QPos> v, std::string name) {
  std::cout << name << ": { ";
  if (v.size() == 0) {
    std::cout << "}\n";
    return;
  }
  // cast mjtNum to float32 and show to 3dp
  for (int i = 0; i < v.size(); i++) {
    printf("\n\txyz = (%.3f, %.3f, %.3f) quat = (%.3f, %.3f, %.3f, %.3f)",
      v[i].x, v[i].y, v[i].z, v[i].qx, v[i].qy, v[i].qz, v[i].qw);
  }
  std::cout << "\n}\n";
}
void print_vec(std::vector<std::string> v, std::string name) {
  std::cout << name << ": { ";
  if (v.size() == 0) {
    std::cout << "}\n";
    return;
  }
  for (int i = 0; i < v.size() - 1; i++) {
    std::cout << v[i] << ", ";
  }
  std::cout << v[v.size() - 1] << " }\n";
}
template <typename T> int sign(T val) {
    return (T(0) < val) - (val < T(0));
}
bool strcmp_w_sub(std::string ref_str, std::string sub_str, int num) {
  /* check if two strings are equal, but one string having a substitued value.
  This value should be indicated by {X}, and will be swapped with integers
  from 1 ... num. */

  if (sub_str.size() < 3) {
    throw std::runtime_error("string compare with substitution failed as input"
      " string has size less than 3, and the substitution value is '{X}'");
  }

  int sub_idx;
  std::string before_sub_str;
  std::string after_sub_str;
  bool found_sub = false;

  // first find the substitution point
  char c1;
  char c2 = sub_str[0];
  char c3 = sub_str[1];

  for (int i = 2; i < sub_str.size(); i++) {

    c1 = c2;
    c2 = c3; 
    c3 = sub_str[i];

    if (c1 == '{' and c2 == 'X' and c3 == '}') {
      before_sub_str = sub_str.substr(0, i - 2);
      if (sub_str.size() == i + 1) {
        after_sub_str = "";
      }
      else {
        after_sub_str = sub_str.substr(i + 1, sub_str.size() - (i + 1));
      }
      found_sub = true;
      break;
    }
  }

  // if the sub string doesn't contain a substitution marker, do normal strcmp
  if (not found_sub) {
    return (ref_str == sub_str);
  }

  // otherwise perform the comparison with substitution
  for (int i = 1; i < num + 1; i++) {

    std::string to_comp = before_sub_str + std::to_string(i) + after_sub_str;

    if (to_comp == ref_str) {
      return true;
    }
  }

  return false;
}

/* ----- global variables and settings ----- */

// global settings for joints in the model
struct JointSettings {

  /* ----- user input settings ----- */

  // keyframes (poses) defined in the xml files
  std::string initial_keyframe = "initial pose";
  std::string reset_keyframe = "initial pose";

  // joint names, need to be hardcoded in here for gripper and panda
  struct Names {
    std::vector<std::string> panda = {
      "panda_joint1", "panda_joint2", "panda_joint3", "panda_joint4",
      "panda_joint5", "panda_joint6", "panda_joint7"
    };
    std::vector<std::string> gripper = {
      "finger_1_prismatic_joint", "finger_1_revolute_joint",
      "finger_2_prismatic_joint", "finger_2_revolute_joint",
      "finger_3_prismatic_joint", "finger_3_revolute_joint",
      "palm_prismatic_joint"
    };
    std::vector<std::string> base = {
      "world_to_base"
    };
    std::vector<std::string> finger;                  // runtime depends
    std::vector<std::string> hook;                    // runtime depends
  } names;

  // gripper specific info for joints (determined by the name order above)
  struct {
    std::vector<int> prismatic { 0, 2, 4 };
    std::vector<int> revolute { 1, 3, 5 };
    std::vector<int> palm { 6 };
  } gripper;

  // key dimensions and details
  struct Dim {
    
    double finger_length = 235e-3;
    double finger_thickness = 0.9e-3;
    double finger_width = 28e-3;
    double E = 200e9;
    double I = (finger_width * std::pow(finger_thickness, 3)) / 12.0;
    double EI = E * I;
    double yield_stress = 215e6;
    double gripper_distance_above_ground = 10e-3;
    bool fixed_first_segment;                         // runtime depends
    bool fixed_hook_segment;                          // runtime depends
    double stiffness_c = 0;                           // runtime depends
    double segment_length = 0;                        // runtime depends
    std::vector<luke::gfloat> joint_stiffness;        // runtime depends

    void update_EI() {
      I = (finger_width * std::pow(finger_thickness, 3)) / 12.0;
      EI = E * I;
    }

    void reset() {
      joint_stiffness.clear();
      update_EI();
    }

  } dim;

  // strain gauge parameters
  struct {
    bool use_armadillo_gauges = true;          // whether to use curve fitting for finger bending
    int order = 3;
    double xpos = 50e-3;
    double cbrt_xpos = std::cbrt(xpos);         // runtime depends
    double xpos_cubed = xpos * xpos * xpos;     // runtime depends
  } gauge;

  // control parameters
  struct {
    bool stepper = true;
    int num_steps = 10;                         // number of stepper motors steps in one chunk
    double pulses_per_s = 2000;                 // stepper motor pulses per second, this sets speed (2000pps = 300rpm)
    Gain kp {100, 40, 1000};                    // proportional gains for gripper xyz motors {x, y, z}
    Gain kd {1, 1, 1};                          // derivative gains for gripper xyz motors {x, y, z}
    double base_kp = 2000;                      // proportional gain for gripper base motions
    double base_kd = 100;                       // derivative gain for gripper base motions
    double time_per_step = 0.0;                 // runtime depends
  } ctrl;

  // hardcoded stiffnesses based on numerical solving
  struct {

    // VALID FOR: real data 1, 235x28x0.9mm fingers, EI=0.34
    struct {

      std::vector<float> N5 { 12.351, 4.728, 5.877, 5.030, 1.927 };
      std::vector<float> N6 { 15.230, 5.923, 6.318, 7.202, 6.383, 2.287 };
      std::vector<float> N7 { 18.861, 7.121, 7.336, 9.602, 8.184, 6.218, 2.000 };
      std::vector<float> N8 { 20.645, 8.041, 8.389, 9.570, 10.123, 8.606, 6.252, 2.079 };
      std::vector<float> N9 { 24.818, 9.799, 9.907, 9.872, 12.627, 11.329, 9.560, 7.562, 2.863 };
      std::vector<float> N10 { 27.302, 11.378, 9.575, 10.845, 14.214, 15.567, 10.791, 9.340, 5.922, 1.816 };
      std::vector<float> N15 { 37.103, 22.431, 15.466, 12.927, 23.115, 15.260, 22.107, 20.695, 21.631, 14.546, 16.221, 12.876, 10.205, 6.744, 2.480 };
      std::vector<float> N20 { 75.206, 23.422, 27.987, 21.172, 16.599, 40.647, 28.657, 19.737, 27.249, 28.612, 34.024, 36.741, 25.092, 21.021, 21.680, 18.867, 14.520, 10.797, 6.767, 1.830 };
      std::vector<float> N25 { 503.022, 16.672, 124.905, 27.550, 24.489, 17.904, 63.461, 34.390, 17.560, 35.540, 69.003, 91.560, 70.231, 63.729, 62.175, 22.117, 6.076, 44.070, 40.950, 65.208, 51.254, 44.330, 25.115, 14.184, 0.500 };
      
      // N30 did not converge to a low error value
      std::vector<float> N30 { 685.194, 18.996, 206.246, 38.443, 27.892, 34.549, 17.070, 57.971, 96.573, 58.083, 11.051, 35.880, 81.274, 140.579, 146.179, 184.276, 219.552, 260.973, 277.488, 303.149, 328.203, 356.418, 351.385, 345.677, 327.709, 298.091, 256.786, 205.697, 144.913, 74.690 };

    } finger_235x28x0p9;

    // VALID FOR: theory data, E=200GPa, length=235mm
    // thickness=0.8 width=28
    struct {

      std::vector<float> N3 { 6.5483, 2.9504, 3.0521 };
      std::vector<float> N4 { 8.4264, 3.8803, 4.0590, 4.0974 };
      std::vector<float> N5 { 10.3266, 4.8018, 5.0145, 5.1343, 5.1315 };
      std::vector<float> N6 { 12.2410, 5.7196, 5.9478, 6.1146, 6.1864, 6.1589 };
      std::vector<float> N7 { 14.1706, 6.6363, 6.8773, 7.0707, 7.1976, 7.2326, 7.1857 };
      std::vector<float> N8 { 16.0972, 7.5545, 7.8013, 8.0128, 8.1740, 8.2632, 8.2699, 8.2098 };
      std::vector<float> N9 { 18.0562, 8.4693, 8.7181, 8.9473, 9.1397, 9.2707, 9.3278, 9.3099, 9.2359 };
      std::vector<float> N10 { 20.0023, 9.3830, 9.6331, 9.8732, 10.0825, 10.2415, 10.3438, 10.3742, 10.3395, 10.2578 };
      std::vector<float> N11 { 21.9659, 10.3053, 10.5499, 10.7948, 11.0212, 11.2114, 11.3479, 11.4193, 11.4270, 11.3745, 11.2824 };
      std::vector<float> N12 { 23.8904, 11.2243, 11.4739, 11.7214, 11.9523, 12.1535, 12.3132, 12.4209, 12.4700, 12.4598, 12.3977, 12.3017 };
      std::vector<float> N13 { 25.8284, 12.1585, 12.3864, 12.6309, 12.8749, 13.0952, 13.2775, 13.4188, 13.5022, 13.5294, 13.5020, 13.4280, 13.3245 };
      std::vector<float> N14 { 27.8489, 13.0669, 13.2924, 13.5474, 13.8028, 14.0399, 14.2398, 14.4006, 14.5154, 14.5782, 14.5867, 14.5426, 14.4576, 14.3472 };
      std::vector<float> N15 { 29.7465, 14.0108, 14.2073, 14.4520, 14.7112, 14.9543, 15.1741, 15.3633, 15.5016, 15.5967, 15.6397, 15.6301, 15.5751, 15.4828, 15.3678 };
      std::vector<float> N16 { 31.7502, 14.9116, 15.1267, 15.3820, 15.6456, 15.8986, 16.1287, 16.3271, 16.4875, 16.6047, 16.6752, 16.6976, 16.6731, 16.6066, 16.5069, 16.3877 };
      std::vector<float> N17 { 33.7309, 15.8359, 16.0344, 16.2904, 16.5604, 16.7974, 17.0408, 17.2677, 17.4460, 17.5905, 17.6933, 17.7448, 17.7536, 17.7153, 17.6395, 17.5329, 17.4091 };
      std::vector<float> N18 { 35.6152, 16.8358, 16.9046, 17.1895, 17.4331, 17.7209, 17.9864, 18.2199, 18.4327, 18.5970, 18.7197, 18.8010, 18.8362, 18.8237, 18.7707, 18.6820, 18.5656, 18.4335 };
      std::vector<float> N19 { 37.6579, 17.6929, 17.8684, 18.1124, 18.3842, 18.6426, 18.8950, 19.1374, 19.3560, 19.5422, 19.6905, 19.7974, 19.8611, 19.8812, 19.8591, 19.7981, 19.7038, 19.5846, 19.4513 };
      std::vector<float> N20 { 39.7350, 18.6337, 18.7506, 18.9763, 19.2553, 19.5519, 19.8438, 20.1164, 20.3607, 20.5611, 20.7212, 20.8458, 20.9310, 20.9729, 20.9703, 20.9299, 20.8540, 20.7467, 20.6172, 20.4757 };
      std::vector<float> N21 { 41.5560, 19.5658, 19.7446, 19.9142, 20.1480, 20.4527, 20.7299, 20.9956, 21.2624, 21.4687, 21.6603, 21.8079, 21.9187, 21.9890, 22.0178, 22.0074, 21.9591, 21.8770, 21.7667, 21.6355, 21.4932 };
      std::vector<float> N22 { 43.4538, 20.6094, 20.5415, 20.8288, 21.0373, 21.3655, 21.6507, 21.9451, 22.2199, 22.4490, 22.6622, 22.8261, 22.9540, 23.0480, 23.0965, 23.1064, 23.0802, 23.0182, 22.9235, 22.8035, 22.6647, 22.5159 };
      std::vector<float> N23 { 45.4771, 21.4392, 21.6006, 21.7312, 21.9500, 22.2512, 22.5747, 22.8452, 23.1116, 23.3641, 23.5902, 23.7825, 23.9290, 24.0397, 24.1144, 24.1517, 24.1518, 24.1159, 24.0465, 23.9475, 23.8241, 23.6833, 23.5335 };
      std::vector<float> N24 { 47.5899, 22.3602, 22.4322, 22.6330, 22.9046, 23.2087, 23.5196, 23.8214, 24.1038, 24.3604, 24.5871, 24.7816, 24.9422, 25.0677, 25.1576, 25.2115, 25.2298, 25.2133, 25.1637, 25.0835, 24.9765, 24.8477, 24.7034, 24.5516 };
      std::vector<float> N25 { 49.6606, 23.3196, 23.3409, 23.5215, 23.7935, 24.1107, 24.4425, 24.7690, 25.0774, 25.3600, 25.6117, 25.8255, 25.9927, 26.1295, 26.2340, 26.3047, 26.3409, 26.3373, 26.3016, 26.2360, 26.1423, 26.0232, 25.8842, 25.7320, 25.5738 };
      std::vector<float> N26 { 51.4575, 24.2236, 24.3079, 24.5155, 24.7903, 24.9973, 25.2839, 25.6044, 25.9295, 26.1908, 26.4427, 26.6810, 26.8829, 27.0409, 27.1758, 27.2762, 27.3344, 27.3645, 27.3592, 27.3201, 27.2533, 27.1570, 27.0377, 26.8996, 26.7481, 26.5906 };
      std::vector<float> N27 { 53.2742, 25.2036, 25.3736, 25.3337, 25.5861, 25.9216, 26.1851, 26.5332, 26.8451, 27.1347, 27.4318, 27.6552, 27.8808, 28.0540, 28.2049, 28.3174, 28.3971, 28.4432, 28.4550, 28.4356, 28.3847, 28.3055, 28.2006, 28.0734, 27.9290, 27.7726, 27.6110 };
      std::vector<float> N28 { 53.9910, 26.4421, 26.6159, 27.1891, 27.3010, 27.5222, 27.5279, 27.5999, 27.5558, 27.5938, 27.5515, 27.6108, 27.5958, 27.6635, 27.7078, 27.7816, 27.8655, 27.9376, 28.0244, 28.0908, 28.1539, 28.2095, 28.2472, 28.2788, 28.3032, 28.3249, 28.3533, 28.3971 };
      std::vector<float> N29 { 55.9106, 27.2882, 27.7144, 28.0273, 28.4382, 28.3649, 28.5017, 28.5286, 28.4978, 28.5580, 28.5281, 28.5330, 28.5956, 28.6194, 28.6693, 28.7523, 28.8287, 28.9003, 28.9834, 29.0674, 29.1302, 29.1876, 29.2373, 29.2765, 29.3027, 29.3242, 29.3454, 29.3729, 29.4156 };
      std::vector<float> N30 { 57.9265, 28.0643, 28.8932, 29.0326, 29.1418, 29.3658, 29.5465, 29.4535, 29.4515, 29.4930, 29.5361, 29.4967, 29.5096, 29.5579, 29.6292, 29.6932, 29.7540, 29.8310, 29.9155, 30.0005, 30.0806, 30.1456, 30.2004, 30.2464, 30.2830, 30.3114, 30.3344, 30.3570, 30.3861, 30.4308 };

      std::vector<int> loops { 32, 38, 41, 41, 43, 44, 46, 46, 48, 48, 49, 50, 50, 51, 51, 48, 48, 47, 47, 47, 47, 48, 49, 48, 49, 112, 112, 113 };
      std::vector<float> errors { 0.043325, 0.04022, 0.039002, 0.041422, 0.039227, 0.039265, 0.036238, 0.039387, 0.035214, 0.036684, 0.036553, 0.036188, 0.038369, 0.037245, 0.039401, 0.040312, 0.040628, 0.043014, 0.042789, 0.044092, 0.044386, 0.046282, 0.049294, 0.046845, 0.048453, 0.043866, 0.043606, 0.042014 };

    } theory_235x28x0p8;

    // thickness=0.9 width=24
    struct {

      std::vector<float> N3 { 8.0989, 3.6014, 3.6937 };
      std::vector<float> N4 { 10.4287, 4.7597, 4.9111, 4.9618 };
      std::vector<float> N5 { 12.7890, 5.9079, 6.0872, 6.1982, 6.2181 };
      std::vector<float> N6 { 15.1588, 7.0585, 7.2475, 7.3955, 7.4706, 7.4698 };
      std::vector<float> N7 { 17.5495, 8.2031, 8.4007, 8.5728, 8.6892, 8.7358, 8.7196 };
      std::vector<float> N8 { 19.9336, 9.3531, 9.5528, 9.7327, 9.8787, 9.9688, 9.9937, 9.9667 };
      std::vector<float> N9 { 22.3605, 10.4968, 10.6882, 10.8826, 11.0544, 11.1811, 11.2472, 11.2534, 11.2157 };
      std::vector<float> N10 { 24.7540, 11.6459, 11.8386, 12.0405, 12.2274, 12.3734, 12.4727, 12.5172, 12.5078, 12.4620 };
      std::vector<float> N11 { 27.1835, 12.7990, 12.9778, 13.1795, 13.3771, 13.5495, 13.6812, 13.7615, 13.7861, 13.7641, 13.7099 };
      std::vector<float> N12 { 29.5530, 13.9512, 14.1377, 14.3412, 14.5405, 14.7157, 14.8631, 14.9700, 15.0294, 15.0405, 15.0100, 14.9523 };
      std::vector<float> N13 { 31.9487, 15.1189, 15.2781, 15.4678, 15.6803, 15.8694, 16.0410, 16.1731, 16.2618, 16.3056, 16.3022, 16.2624, 16.1986 };
      std::vector<float> N14 { 34.4285, 16.2602, 16.4126, 16.6134, 16.8291, 17.0378, 17.2245, 17.3782, 17.4894, 17.5581, 17.5831, 17.5669, 17.5169, 17.4458 };
      std::vector<float> N15 { 36.7611, 17.4399, 17.5696, 17.7554, 17.9770, 18.1806, 18.3827, 18.5495, 18.6861, 18.7826, 18.8352, 18.8481, 18.8211, 18.7646, 18.6898 };
      std::vector<float> N16 { 39.2397, 18.5709, 18.7086, 18.9024, 19.1190, 19.3368, 19.5395, 19.7171, 19.8685, 19.9860, 20.0654, 20.1048, 20.1053, 20.0713, 20.0100, 19.9327 };
      std::vector<float> N17 { 41.6648, 19.7292, 19.8546, 20.0479, 20.2722, 20.4681, 20.6764, 20.8778, 21.0526, 21.1862, 21.2900, 21.3561, 21.3802, 21.3700, 21.3272, 21.2597, 21.1778 };
      std::vector<float> N18 { 43.9853, 20.9739, 20.9579, 21.1849, 21.3642, 21.6140, 21.8362, 22.0507, 22.2463, 22.3983, 22.5247, 22.6108, 22.6575, 22.6691, 22.6453, 22.5912, 22.5149, 22.4256 };
      std::vector<float> N19 { 46.4897, 22.0523, 22.1604, 22.3410, 22.5575, 22.7548, 22.9696, 23.1845, 23.3841, 23.5588, 23.7025, 23.8118, 23.8849, 23.9215, 23.9230, 23.8925, 23.8346, 23.7564, 23.6665 };
      std::vector<float> N20 { 49.0286, 23.2300, 23.2752, 23.4316, 23.6489, 23.8934, 24.1427, 24.3820, 24.6013, 24.7938, 24.9498, 25.0691, 25.1568, 25.2108, 25.2305, 25.2163, 25.1711, 25.1015, 25.0136, 24.9153 };
      std::vector<float> N21 { 51.2774, 24.3898, 24.5120, 24.6154, 24.7790, 25.0255, 25.2659, 25.4866, 25.7191, 25.9159, 26.0872, 26.2395, 26.3442, 26.4248, 26.4682, 26.4795, 26.4603, 26.4120, 26.3414, 26.2529, 26.1554 };
      std::vector<float> N22 { 53.6232, 25.6862, 25.5290, 25.7549, 25.8824, 26.1597, 26.3840, 26.6471, 26.8804, 27.0956, 27.2948, 27.4479, 27.5828, 27.6772, 27.7398, 27.7728, 27.7689, 27.7378, 27.6808, 27.6009, 27.5059, 27.4022 };
      std::vector<float> N23 { 56.1032, 26.7303, 26.8400, 26.8890, 27.0361, 27.2785, 27.5481, 27.7640, 27.9992, 28.2301, 28.4425, 28.6094, 28.7529, 28.8697, 28.9562, 29.0109, 29.0308, 29.0209, 28.9841, 28.9232, 28.8421, 28.7464, 28.6429 };
      std::vector<float> N24 { 58.7077, 27.8909, 27.8852, 28.0035, 28.1976, 28.4334, 28.6873, 28.9431, 29.1897, 29.4196, 29.6220, 29.8023, 29.9580, 30.0864, 30.1858, 30.2551, 30.2943, 30.3040, 30.2855, 30.2413, 30.1745, 30.0892, 29.9907, 29.8853 };
      std::vector<float> N25 { 61.2567, 29.0934, 29.0233, 29.1082, 29.2908, 29.5301, 29.7975, 30.0730, 30.3428, 30.5976, 30.8310, 31.0389, 31.2182, 31.3578, 31.4684, 31.5507, 31.6040, 31.6280, 31.6234, 31.5906, 31.5322, 31.4532, 31.3572, 31.2491, 31.1348 };
      std::vector<float> N26 { 63.4573, 30.2110, 30.2323, 30.3650, 30.5677, 30.6983, 30.9135, 31.1744, 31.4513, 31.6937, 31.9123, 32.1265, 32.3255, 32.4823, 32.6125, 32.7210, 32.8000, 32.8431, 32.8620, 32.8552, 32.8187, 32.7609, 32.6836, 32.5891, 32.4837, 32.3726 };
      std::vector<float> N27 { 65.7121, 31.4260, 31.5513, 31.4106, 31.5748, 31.8430, 32.0248, 32.3079, 32.5855, 32.8274, 33.0951, 33.3075, 33.5120, 33.6956, 33.8375, 33.9676, 34.0523, 34.1183, 34.1515, 34.1586, 34.1396, 34.0950, 34.0297, 33.9442, 33.8445, 33.7337, 33.6179 };
      std::vector<float> N28 { 68.0605, 32.7618, 32.4645, 32.6166, 32.6936, 32.9409, 33.1652, 33.4510, 33.7128, 33.9923, 34.2377, 34.4851, 34.6890, 34.8903, 35.0422, 35.1889, 35.2860, 35.3694, 35.4174, 35.4413, 35.4391, 35.4098, 35.3601, 35.2867, 35.1972, 35.0933, 34.9796, 34.8613 };
      std::vector<float> N29 { 70.4680, 33.8643, 33.7213, 33.7242, 33.9555, 34.0459, 34.3279, 34.5781, 34.8378, 35.1496, 35.3744, 35.6228, 35.8617, 36.0460, 36.2267, 36.3818, 36.4963, 36.5937, 36.6652, 36.7012, 36.7160, 36.7074, 36.6703, 36.6131, 36.5373, 36.4440, 36.3376, 36.2225, 36.1030 };
      std::vector<float> N30 { 72.9778, 34.9230, 35.0202, 34.9349, 34.9791, 35.2036, 35.4793, 35.6762, 35.9460, 36.2464, 36.5142, 36.7478, 36.9836, 37.2084, 37.4008, 37.5553, 37.6922, 37.8070, 37.8967, 37.9512, 37.9807, 37.9871, 37.9702, 37.9305, 37.8681, 37.7872, 37.6912, 37.5829, 37.4661, 37.3453 };

      std::vector<int> loops { 33, 43, 48, 52, 55, 57, 59, 61, 63, 64, 65, 67, 67, 67, 68, 70, 70, 72, 72, 73, 73, 73, 75, 75, 76, 76, 77, 77 };
      std::vector<float> errors { 0.047113, 0.045211, 0.0457, 0.044584, 0.044236, 0.044282, 0.045494, 0.044128, 0.044088, 0.04271, 0.044017, 0.042692, 0.042024, 0.043962, 0.043978, 0.042872, 0.043015, 0.042203, 0.042159, 0.042963, 0.04286, 0.043729, 0.042865, 0.041393, 0.041853, 0.043408, 0.040854, 0.041439 };

    } theory_235x24x0p9;

    // thickness=0.9 width=28
    struct {

      std::vector<float> N3 { 9.5902, 4.2163, 4.2853 };
      std::vector<float> N4 { 12.4107, 5.5895, 5.6626, 5.7290 };
      std::vector<float> N5 { 15.2582, 6.9727, 7.0309, 7.1062, 7.1730 };
      std::vector<float> N6 { 18.1174, 8.3681, 8.4017, 8.4727, 8.5487, 8.6172 };
      std::vector<float> N7 { 20.9795, 9.7603, 9.7733, 9.8350, 9.9143, 9.9915, 10.0622 };
      std::vector<float> N8 { 23.8480, 11.1678, 11.1585, 11.2013, 11.2744, 11.3559, 11.4340, 11.5069 };
      std::vector<float> N9 { 26.7393, 12.5832, 12.5461, 12.5714, 12.6343, 12.7145, 12.7977, 12.8768, 12.9520 };
      std::vector<float> N10 { 29.6147, 13.9986, 13.9427, 13.9507, 14.0013, 14.0751, 14.1577, 14.2413, 14.3211, 14.3978 };
      std::vector<float> N11 { 32.4939, 15.4098, 15.3321, 15.3217, 15.3593, 15.4269, 15.5099, 15.5977, 15.6835, 15.7649, 15.8436 };
      std::vector<float> N12 { 35.3560, 16.8257, 16.7387, 16.7151, 16.7373, 16.7922, 16.8683, 16.9544, 17.0424, 17.1281, 17.2101, 17.2900 };
      std::vector<float> N13 { 38.2310, 18.2562, 18.1498, 18.1042, 18.1148, 18.1565, 18.2268, 18.3082, 18.3971, 18.4856, 18.5718, 18.6547, 18.7362 };
      std::vector<float> N14 { 41.1297, 19.6669, 19.5412, 19.4829, 19.4781, 19.5133, 19.5763, 19.6567, 19.7461, 19.8383, 19.9288, 20.0161, 20.1002, 20.1828 };
      std::vector<float> N15 { 43.9784, 21.0964, 20.9587, 20.8841, 20.8683, 20.8865, 20.9415, 21.0123, 21.0990, 21.1896, 21.2826, 21.3732, 21.4609, 21.5457, 21.6294 };
      std::vector<float> N16 { 46.8826, 22.5170, 22.3720, 22.2894, 22.2585, 22.2689, 22.3078, 22.3714, 22.4513, 22.5404, 22.6335, 22.7266, 22.8176, 22.9057, 22.9913, 23.0760 };
      std::vector<float> N17 { 49.7693, 23.9476, 23.7913, 23.6971, 23.6550, 23.6467, 23.6748, 23.7313, 23.8069, 23.8915, 23.9830, 24.0775, 24.1710, 24.2620, 24.3505, 24.4369, 24.5227 };
      std::vector<float> N18 { 52.6029, 25.3917, 25.1844, 25.0881, 25.0169, 25.0088, 25.0272, 25.0785, 25.1491, 25.2326, 25.3267, 25.4217, 25.5189, 25.6142, 25.7065, 25.7960, 25.8832, 25.9698 };
      std::vector<float> N19 { 55.5156, 26.7875, 26.6136, 26.4982, 26.4335, 26.3987, 26.4065, 26.4461, 26.5089, 26.5878, 26.6771, 26.7721, 26.8685, 26.9651, 27.0600, 27.1523, 27.2419, 27.3296, 27.4168 };
      std::vector<float> N20 { 58.4497, 28.2420, 28.0397, 27.9003, 27.8158, 27.7777, 27.7781, 27.8096, 27.8651, 27.9385, 28.0242, 28.1167, 28.2129, 28.3108, 28.4083, 28.5038, 28.5967, 28.6869, 28.7753, 28.8635 };
      std::vector<float> N21 { 61.2659, 29.6533, 29.4794, 29.3290, 29.2259, 29.1810, 29.1720, 29.1868, 29.2338, 29.2996, 29.3766, 29.4667, 29.5612, 29.6587, 29.7580, 29.8545, 29.9498, 30.0425, 30.1328, 30.2219, 30.3106 };
      std::vector<float> N22 { 64.1245, 31.1411, 30.8797, 30.7522, 30.6252, 30.5767, 30.5453, 30.5605, 30.5942, 30.6529, 30.7268, 30.8111, 30.9057, 31.0014, 31.1013, 31.2001, 31.2977, 31.3936, 31.4865, 31.5777, 31.6676, 31.7573 };
      std::vector<float> N23 { 67.0262, 32.5216, 32.3422, 32.1645, 32.0413, 31.9762, 31.9492, 31.9416, 31.9685, 32.0208, 32.0883, 32.1658, 32.2547, 32.3505, 32.4497, 32.5482, 32.6469, 32.7444, 32.8399, 32.9331, 33.0243, 33.1144, 33.2046 };
      std::vector<float> N24 { 69.9714, 33.9653, 33.7417, 33.5727, 33.4527, 33.3759, 33.3368, 33.3299, 33.3501, 33.3893, 33.4475, 33.5209, 33.6054, 33.6976, 33.7945, 33.8938, 33.9937, 34.0928, 34.1902, 34.2856, 34.3789, 34.4705, 34.5611, 34.6518 };
      std::vector<float> N25 { 72.8889, 35.4051, 35.1554, 34.9645, 34.8262, 34.7347, 34.6841, 34.6684, 34.6825, 34.7211, 34.7794, 34.8533, 34.9388, 35.0326, 35.1305, 35.2311, 35.3334, 35.4355, 35.5364, 35.6352, 35.7315, 35.8255, 35.9175, 36.0084, 36.0993 };
      std::vector<float> N26 { 75.6899, 36.7956, 36.5730, 36.4012, 36.2754, 36.1585, 36.0912, 36.0661, 36.0746, 36.1048, 36.1490, 36.2142, 36.2947, 36.3848, 36.4778, 36.5772, 36.6800, 36.7826, 36.8838, 36.9842, 37.0827, 37.1784, 37.2721, 37.3643, 37.4555, 37.5467 };
      std::vector<float> N27 { 78.5178, 38.2389, 38.0609, 37.8116, 37.6638, 37.5737, 37.4850, 37.4532, 37.4530, 37.4664, 37.5125, 37.5709, 37.6431, 37.7317, 37.8206, 37.9194, 38.0208, 38.1231, 38.2273, 38.3283, 38.4290, 38.5272, 38.6233, 38.7175, 38.8100, 38.9019, 38.9937 };
      std::vector<float> N28 { 81.3729, 39.7361, 39.4278, 39.2537, 39.0765, 38.9690, 38.8851, 38.8441, 38.8290, 38.8425, 38.8767, 38.9305, 38.9981, 39.0790, 39.1672, 39.2640, 39.3629, 39.4666, 39.5689, 39.6733, 39.7743, 39.8751, 39.9730, 40.0693, 40.1635, 40.2564, 40.3487, 40.4410 };
      std::vector<float> N29 { 84.2553, 41.1425, 40.8799, 40.6622, 40.5251, 40.3720, 40.2977, 40.2390, 40.2142, 40.2286, 40.2457, 40.2947, 40.3577, 40.4298, 40.5178, 40.6089, 40.7062, 40.8095, 40.9113, 41.0149, 41.1191, 41.2203, 41.3204, 41.4190, 41.5150, 41.6095, 41.7028, 41.7954, 41.8882 };
      std::vector<float> N30 { 87.1654, 42.5336, 42.3434, 42.1060, 41.9152, 41.7940, 41.7092, 41.6316, 41.6006, 41.6047, 41.6209, 41.6559, 41.7132, 41.7871, 41.8647, 41.9524, 42.0486, 42.1502, 42.2519, 42.3550, 42.4592, 42.5631, 42.6652, 42.7650, 42.8633, 42.9599, 43.0549, 43.1486, 43.2418, 43.3352 };

      std::vector<int> loops { 18, 18, 18, 18, 19, 18, 18, 18, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 21 };
      std::vector<float> errors { 0.042351, 0.042565, 0.041487, 0.042341, 0.041259, 0.041158, 0.041653, 0.042385, 0.041881, 0.041955, 0.042631, 0.042198, 0.042508, 0.042765, 0.043347, 0.04326, 0.04318, 0.043994, 0.043976, 0.044771, 0.044575, 0.044795, 0.04495, 0.044569, 0.045074, 0.045479, 0.045558, 0.045666 };
     
    } theory_235x28x0p9;

    // thickness=1.0 width=24
    struct {

      std::vector<float> N3 { 11.3302, 4.9872, 5.0485 };
      std::vector<float> N4 { 14.6610, 6.6243, 6.6840, 6.7460 };
      std::vector<float> N5 { 18.0127, 8.2666, 8.3127, 8.3790, 8.4438 };
      std::vector<float> N6 { 21.3815, 9.9234, 9.9457, 10.0055, 10.0748, 10.1423 };
      std::vector<float> N7 { 24.7646, 11.5851, 11.5866, 11.6334, 11.7004, 11.7715, 11.8415 };
      std::vector<float> N8 { 28.1347, 13.2461, 13.2298, 13.2604, 13.3214, 13.3939, 13.4678, 13.5407 };
      std::vector<float> N9 { 31.5367, 14.9215, 14.8803, 14.8949, 14.9449, 15.0136, 15.0890, 15.1649, 15.2403 };
      std::vector<float> N10 { 34.9118, 16.5847, 16.5282, 16.5290, 16.5692, 16.6329, 16.7071, 16.7851, 16.8629, 16.9405 };
      std::vector<float> N11 { 38.3142, 18.2691, 18.1920, 18.1739, 18.1988, 18.2525, 18.3229, 18.4010, 18.4811, 18.5607, 18.6404 };
      std::vector<float> N12 { 41.6848, 19.9423, 19.8592, 19.8305, 19.8407, 19.8823, 19.9452, 20.0198, 20.0995, 20.1802, 20.2606, 20.3415 };
      std::vector<float> N13 { 45.0576, 21.6178, 21.5174, 21.4689, 21.4726, 21.5026, 21.5613, 21.6317, 21.7118, 21.7939, 21.8769, 21.9591, 22.0419 };
      std::vector<float> N14 { 48.4822, 23.3037, 23.1859, 23.1257, 23.1120, 23.1342, 23.1824, 23.2483, 23.3249, 23.4070, 23.4909, 23.5749, 23.6584, 23.7427 };
      std::vector<float> N15 { 51.8389, 24.9904, 24.8636, 24.7890, 24.7671, 24.7728, 24.8140, 24.8695, 24.9423, 25.0208, 25.1048, 25.1892, 25.2741, 25.3585, 25.4438 };
      std::vector<float> N16 { 55.2414, 26.6530, 26.5196, 26.4399, 26.4053, 26.4063, 26.4331, 26.4840, 26.5515, 26.6294, 26.7131, 26.7993, 26.8860, 26.9722, 27.0581, 27.1447 };
      std::vector<float> N17 { 58.6372, 28.3399, 28.1969, 28.1070, 28.0626, 28.0478, 28.0647, 28.1083, 28.1707, 28.2443, 28.3244, 28.4098, 28.4973, 28.5845, 28.6714, 28.7582, 28.8459 };
      std::vector<float> N18 { 61.9953, 30.0629, 29.8717, 29.7827, 29.7084, 29.6927, 29.6973, 29.7344, 29.7876, 29.8561, 29.9347, 30.0181, 30.1059, 30.1937, 30.2821, 30.3701, 30.4580, 30.5470 };
      std::vector<float> N19 { 65.4181, 31.7140, 31.5593, 31.4527, 31.3869, 31.3455, 31.3421, 31.3677, 31.4149, 31.4779, 31.5520, 31.6318, 31.7169, 31.8047, 31.8934, 31.9821, 32.0705, 32.1591, 32.2486 };
      std::vector<float> N20 { 68.8514, 33.4099, 33.2255, 33.0950, 33.0118, 32.9693, 32.9609, 32.9805, 33.0224, 33.0815, 33.1533, 33.2338, 33.3193, 33.4077, 33.4980, 33.5886, 33.6790, 33.7689, 33.8588, 33.9496 };
      std::vector<float> N21 { 72.1721, 35.0750, 34.9222, 34.7830, 34.6823, 34.6343, 34.6195, 34.6225, 34.6560, 34.7096, 34.7714, 34.8474, 34.9309, 35.0170, 35.1072, 35.1980, 35.2887, 35.3794, 35.4695, 35.5599, 35.6512 };
      std::vector<float> N22 { 75.5378, 36.8223, 36.5791, 36.4659, 36.3419, 36.2935, 36.2543, 36.2611, 36.2811, 36.3274, 36.3857, 36.4571, 36.5374, 36.6222, 36.7124, 36.8026, 36.8948, 36.9863, 37.0777, 37.1689, 37.2601, 37.3524 };
      std::vector<float> N23 { 78.9493, 38.4546, 38.3001, 38.1349, 38.0178, 37.9536, 37.9206, 37.9044, 37.9205, 37.9604, 38.0121, 38.0759, 38.1517, 38.2354, 38.3220, 38.4115, 38.5030, 38.5953, 38.6872, 38.7786, 38.8699, 38.9616, 39.0543 };
      std::vector<float> N24 { 82.4068, 40.1546, 39.9547, 39.8009, 39.6888, 39.6138, 39.5715, 39.5574, 39.5657, 39.5914, 39.6359, 39.6952, 39.7659, 39.8450, 39.9300, 40.0188, 40.1100, 40.2022, 40.2947, 40.3869, 40.4789, 40.5706, 40.6628, 40.7559 };
      std::vector<float> N25 { 85.8532, 41.8773, 41.6571, 41.4850, 41.3565, 41.2671, 41.2121, 41.1873, 41.1884, 41.2115, 41.2527, 41.3087, 41.3764, 41.4531, 41.5365, 41.6238, 41.7137, 41.8056, 41.8986, 41.9918, 42.0848, 42.1776, 42.2703, 42.3633, 42.4573 };
      std::vector<float> N26 { 89.1612, 43.5215, 43.3298, 43.1785, 43.0643, 42.9523, 42.8822, 42.8491, 42.8455, 42.8635, 42.8907, 42.9378, 43.0001, 43.0736, 43.1507, 43.2344, 43.3233, 43.4152, 43.5072, 43.6000, 43.6933, 43.7865, 43.8791, 43.9718, 44.0650, 44.1592 };
      std::vector<float> N27 { 92.4797, 45.2004, 45.0547, 44.8223, 44.6859, 44.6026, 44.5116, 44.4739, 44.4665, 44.4668, 44.4983, 44.5437, 44.5992, 44.6714, 44.7471, 44.8310, 44.9214, 45.0116, 45.1059, 45.2003, 45.2949, 45.3899, 45.4837, 45.5777, 45.6714, 45.7655, 45.8606 };
      std::vector<float> N28 { 95.8420, 46.9565, 46.6753, 46.5228, 46.3583, 46.2566, 46.1739, 46.1278, 46.1059, 46.1071, 46.1297, 46.1674, 46.2213, 46.2851, 46.3595, 46.4403, 46.5270, 46.6174, 46.7101, 46.8047, 46.8995, 46.9949, 47.0895, 47.1842, 47.2782, 47.3724, 47.4669, 47.5624 };
      std::vector<float> N29 { 99.2331, 48.6166, 48.3842, 48.1883, 48.0661, 47.9198, 47.8487, 47.7854, 47.7544, 47.7576, 47.7629, 47.7992, 47.8452, 47.9029, 47.9767, 48.0507, 48.1349, 48.2246, 48.3146, 48.4090, 48.5040, 48.5989, 48.6946, 48.7896, 48.8842, 48.9788, 49.0733, 49.1682, 49.2641 };
      std::vector<float> N30 { 102.6533, 50.2607, 50.1061, 49.8906, 49.7151, 49.6039, 49.5215, 49.4420, 49.4060, 49.4024, 49.4045, 49.4268, 49.4704, 49.5290, 49.5893, 49.6624, 49.7447, 49.8319, 49.9201, 50.0126, 50.1077, 50.2034, 50.2984, 50.3940, 50.4895, 50.5847, 50.6793, 50.7742, 50.8695, 50.9659 };

      std::vector<int> loops { 24, 24, 25, 24, 24, 25, 25, 26, 26, 26, 27, 27, 27, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30 };
      std::vector<float> errors { 0.042639, 0.041616, 0.038276, 0.039562, 0.041155, 0.039058, 0.041242, 0.038488, 0.040731, 0.041547, 0.039109, 0.040476, 0.041573, 0.038444, 0.039448, 0.041084, 0.041287, 0.038486, 0.039055, 0.040409, 0.040513, 0.040723, 0.04173, 0.041764, 0.038995, 0.03968, 0.040234, 0.040573 };

    } theory_235x24x1p0;

    // thickness=1.0 width=28
    struct {

      std::vector<float> N3 { 13.2683, 5.8481, 5.9014 };
      std::vector<float> N4 { 17.1624, 7.7754, 7.8242, 7.8816 };
      std::vector<float> N5 { 21.0889, 9.7143, 9.7468, 9.8027, 9.8634 };
      std::vector<float> N6 { 25.0210, 11.6585, 11.6703, 11.7188, 11.7805, 11.8451 };
      std::vector<float> N7 { 28.9663, 13.6041, 13.5987, 13.6354, 13.6935, 13.7593, 13.8275 };
      std::vector<float> N8 { 32.9130, 15.5625, 15.5401, 15.5597, 15.6089, 15.6720, 15.7402, 15.8110 };
      std::vector<float> N9 { 36.8768, 17.5195, 17.4757, 17.4817, 17.5209, 17.5796, 17.6477, 17.7195, 17.7937 };
      std::vector<float> N10 { 40.8291, 19.4809, 19.4237, 19.4160, 19.4439, 19.4949, 19.5588, 19.6289, 19.7023, 19.7780 };
      std::vector<float> N11 { 44.7926, 21.4446, 21.3695, 21.3458, 21.3609, 21.4031, 21.4626, 21.5318, 21.6060, 21.6824, 21.7612 };
      std::vector<float> N12 { 48.7304, 23.4042, 23.3255, 23.2936, 23.2947, 23.3255, 23.3772, 23.4418, 23.5135, 23.5889, 23.6663, 23.7461 };
      std::vector<float> N13 { 52.6736, 25.3692, 25.2754, 25.2245, 25.2211, 25.2398, 25.2859, 25.3453, 25.4152, 25.4901, 25.5681, 25.6479, 25.7299 };
      std::vector<float> N14 { 56.6665, 27.3421, 27.2327, 27.1724, 27.1525, 27.1647, 27.2011, 27.2549, 27.3205, 27.3933, 27.4704, 27.5499, 27.6311, 27.7145 };
      std::vector<float> N15 { 60.5812, 29.3038, 29.1864, 29.1131, 29.0880, 29.0853, 29.1161, 29.1615, 29.2235, 29.2934, 29.3698, 29.4491, 29.5306, 29.6136, 29.6987 };
      std::vector<float> N16 { 64.5639, 31.2667, 31.1456, 31.0695, 31.0318, 31.0237, 31.0395, 31.0780, 31.1329, 31.1990, 31.2725, 31.3506, 31.4313, 31.5137, 31.5976, 31.6837 };
      std::vector<float> N17 { 68.5274, 33.2397, 33.1108, 33.0261, 32.9798, 32.9592, 32.9656, 32.9966, 33.0458, 33.1078, 33.1763, 33.2517, 33.3314, 33.4134, 33.4966, 33.5816, 33.6687 };
      std::vector<float> N18 { 72.4426, 35.2375, 35.0593, 34.9775, 34.9023, 34.8825, 34.8780, 34.9055, 34.9465, 35.0042, 35.0713, 35.1456, 35.2253, 35.3071, 35.3916, 35.4769, 35.5639, 35.6528 };
      std::vector<float> N19 { 76.4339, 37.1722, 37.0333, 36.9351, 36.8701, 36.8251, 36.8148, 36.8309, 36.8674, 36.9191, 36.9808, 37.0504, 37.1267, 37.2072, 37.2904, 37.3752, 37.4613, 37.5487, 37.6382 };
      std::vector<float> N20 { 80.4481, 39.1713, 39.0066, 38.8866, 38.8062, 38.7604, 38.7442, 38.7528, 38.7818, 38.8270, 38.8849, 38.9523, 39.0266, 39.1052, 39.1870, 39.2712, 39.3570, 39.4442, 39.5327, 39.6232 };
      std::vector<float> N21 { 84.3360, 41.1205, 40.9887, 40.8622, 40.7659, 40.7160, 40.6958, 40.6887, 40.7096, 40.7508, 40.7984, 40.8603, 40.9320, 41.0065, 41.0867, 41.1703, 41.2547, 41.3411, 41.4287, 41.5177, 41.6086 };
      std::vector<float> N22 { 88.2575, 43.1415, 42.9170, 42.8170, 42.6973, 42.6496, 42.6048, 42.6046, 42.6134, 42.6489, 42.6940, 42.7538, 42.8215, 42.8962, 42.9764, 43.0591, 43.1451, 43.2318, 43.3203, 43.4096, 43.5004, 43.5929 };
      std::vector<float> N23 { 92.2369, 45.0566, 44.9245, 44.7721, 44.6617, 44.5991, 44.5618, 44.5390, 44.5462, 44.5756, 44.6138, 44.6657, 44.7298, 44.8025, 44.8777, 44.9585, 45.0428, 45.1292, 45.2163, 45.3048, 45.3946, 45.4857, 45.5785 };
      std::vector<float> N24 { 96.2638, 47.0422, 46.8645, 46.7254, 46.6214, 46.5490, 46.5047, 46.4849, 46.4831, 46.4982, 46.5311, 46.5783, 46.6369, 46.7042, 46.7783, 46.8573, 46.9399, 47.0250, 47.1119, 47.1999, 47.2890, 47.3791, 47.4706, 47.5639 };
      std::vector<float> N25 { 100.2791, 49.0513, 48.8544, 48.6980, 48.5785, 48.4925, 48.4363, 48.4064, 48.3995, 48.4123, 48.4419, 48.4856, 48.5407, 48.6050, 48.6766, 48.7537, 48.8348, 48.9183, 49.0043, 49.0921, 49.1811, 49.2712, 49.3624, 49.4549, 49.5490 };
      std::vector<float> N26 { 104.1519, 50.9775, 50.8105, 50.6763, 50.5727, 50.4660, 50.3956, 50.3583, 50.3475, 50.3578, 50.3736, 50.4083, 50.4576, 50.5183, 50.5849, 50.6568, 50.7350, 50.8176, 50.9026, 50.9886, 51.0767, 51.1661, 51.2565, 51.3477, 51.4403, 51.5347 };
      std::vector<float> N27 { 108.0530, 52.9606, 52.8443, 52.6331, 52.5094, 52.4333, 52.3430, 52.3008, 52.2871, 52.2766, 52.2948, 52.3278, 52.3680, 52.4246, 52.4872, 52.5565, 52.6342, 52.7129, 52.7964, 52.8828, 52.9697, 53.0589, 53.1488, 53.2397, 53.3318, 53.4250, 53.5200 };
      std::vector<float> N28 { 111.9685, 54.9878, 54.7327, 54.6000, 54.4482, 54.3529, 54.2725, 54.2232, 54.1963, 54.1879, 54.2011, 54.2256, 54.2678, 54.3172, 54.3796, 54.4466, 54.5223, 54.6007, 54.6844, 54.7697, 54.8579, 54.9470, 55.0375, 55.1288, 55.2211, 55.3143, 55.4087, 55.5048 };
      std::vector<float> N29 { 115.9269, 56.9315, 56.7269, 56.5516, 56.4433, 56.3048, 56.2374, 56.1716, 56.1365, 56.1308, 56.1269, 56.1527, 56.1846, 56.2301, 56.2903, 56.3511, 56.4236, 56.5004, 56.5805, 56.6659, 56.7518, 56.8403, 56.9306, 57.0210, 57.1129, 57.2055, 57.2991, 57.3939, 57.4903 };
      std::vector<float> N30 { 119.9152, 58.8591, 58.7351, 58.5406, 58.3799, 58.2784, 58.1993, 58.1197, 58.0804, 58.0707, 58.0619, 58.0738, 58.1059, 58.1499, 58.1976, 58.2581, 58.3281, 58.4015, 58.4789, 58.5615, 58.6478, 58.7346, 58.8233, 58.9137, 59.0053, 59.0972, 59.1901, 59.2841, 59.3792, 59.4759 };

      std::vector<int> loops { 28, 29, 29, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35, 35, 35, 36, 36, 36, 36, 37, 37, 37, 37, 37, 37, 38, 38, 38 };
      std::vector<float> errors { 0.044879, 0.043071, 0.044228, 0.04342, 0.042447, 0.044065, 0.043433, 0.044447, 0.043791, 0.044385, 0.043179, 0.044258, 0.042682, 0.043277, 0.044049, 0.042974, 0.043067, 0.044032, 0.044351, 0.043032, 0.042976, 0.043241, 0.044292, 0.044333, 0.045014, 0.042931, 0.042984, 0.043058 };

    } theory_235x28x1p0;

  } hardcoded_c;

  /* ----- automatically generated settings ----- */

  // is this part of the model in use
  struct InUse {
    bool panda = false;
    bool gripper = false;
    bool finger = false;
    bool base = false;
  } in_use;

  // how many joints for each part
  struct JointNum {
    int panda = 0;
    int gripper = 0;
    int finger = 0;
    int per_finger = 0;
    int base = 0;
  } num;

  VectorStruct<int> idx;
  VectorStruct<int> qposadr;
  VectorStruct<int> qveladr;
  VectorStruct<mjtNum> qpos;
  VectorStruct<mjtNum> qvel;
  VectorStruct<mjtNum*> to_qpos;
  VectorStruct<mjtNum*> to_qvel;

  // joint weld constraint indexes (for freezing/fixing joints)
  struct ConIdx {
    std::vector<int> prismatic;
    std::vector<int> revolute;
    std::vector<int> palm;
  } con_idx;

  // segmented finger geom ids for colour changing fingers
  struct GeomIdx {
    std::vector<int> finger1;
    std::vector<int> finger2;
    std::vector<int> finger3;
    std::vector<int> palm;
  } geom_idx;

  // segement matrix (3x3) orientations
  struct SegmentMatrices {
    mjtNum finger1[9];
    mjtNum finger2[9];
    mjtNum finger3[9];
    // std::vector<mjtNum*> fingers { finger1, finger2, finger3 };
    int idx_size;
    std::vector<int> f1_idx;
    std::vector<int> f2_idx;
    std::vector<int> f3_idx;
    std::vector<int> apply_flags;
    std::vector<float> force;
  } segmentMatrices;

  /* ----- Member functions ----- */

  // only resets the automatically generated settings
  void reset() {

    // special case, reset joint stiffness vector
    dim.reset();

    // reset the VectorStructs
    idx.reset();
    qposadr.reset();
    qveladr.reset();
    qpos.reset();
    qvel.reset();
    to_qpos.reset();
    to_qvel.reset();

    // reset other custom structs
    Names names_reset;
    names = names_reset;

    ConIdx con_idx_reset;
    con_idx = con_idx_reset;

    GeomIdx geom_idx_reset;
    geom_idx = geom_idx_reset;

    InUse in_use_reset;
    in_use = in_use_reset;

    JointNum joint_num_reset;
    num = joint_num_reset;

    SegmentMatrices seg_mat_reset;
    segmentMatrices = seg_mat_reset;
  }

  // printing functions
  void print_idx() {
    print_vec(idx.panda, "panda joint idx");
    print_vec(idx.gripper, "gripper joint idx");
    print_vec(idx.finger, "finger joint idx");
    print_vec(idx.base, "base joint idx");
  }
  void print_in_use() {
    std::cout << "Using: " 
      << "panda = " << (in_use.panda ? "true" : "false")
      << ", gripper = " << (in_use.gripper ? "true" : "false")
      << ", segmented fingers = " << (in_use.finger ? "true" : "false")
      << ", base = " << (in_use.gripper ? "true" : "false")
      << '\n';
  }
  void print_num() {
    std::cout << "Number of joints for: "
      << "panda = " << num.panda
      << ", gripper = " << num.gripper 
      << ", finger = " << num.finger
      << ", per finger = " << num.per_finger 
      << ", base = " << num.base
      << '\n';
  }
  void print_qposadr() {
    print_vec(qposadr.panda, "panda joint qpos addresses");
    print_vec(qposadr.gripper, "gripper joint qpos addresses");
    print_vec(qposadr.finger, "finger joint qpos addresses");
    print_vec(qposadr.base, "base joint qpos addresses");
  }
  void print_qveladr() {
    print_vec(qveladr.panda, "panda joint qvel addresses");
    print_vec(qveladr.gripper, "gripper joint qvel addresses");
    print_vec(qveladr.finger, "finger joint qvel addresses");
    print_vec(qveladr.base, "base joint qvel addresses");
  }
  void print_qpos() {
    std::cout << "Please note, qpos and qvel are no longer used. To see them for "
      "debugging, please run the function update_state() before printing\n";
    print_vec(qpos.panda, "panda joint qpos");
    print_vec(qpos.gripper, "gripper joint qpos");
    print_vec(qpos.finger, "finger joint qpos");
    print_vec(qpos.base, "base joint qpos");
  }
  void print_qvel() {
    std::cout << "Please note, qpos and qvel are no longer used. To see them for "
      "debugging, please run the function update_state() before printing\n";
    print_vec(qvel.panda, "panda joint qvel");
    print_vec(qvel.gripper, "gripper joint qvel");
    print_vec(qvel.finger, "finger joint qvel");
    print_vec(qvel.base, "base joint qvel");
  }
  void print_geom_idx() {
    print_vec(geom_idx.finger1, "finger1 geom idx");
    print_vec(geom_idx.finger2, "finger2 geom idx");
    print_vec(geom_idx.finger3, "finger3 geom idx");
    print_vec(geom_idx.palm, "palm geom idx");
  }
  
};

// global joint settings structure
JointSettings j_;

// create object handler to control graspable objects in simulation
ObjectHandler oh_;

// global state target for gripper joints
Target target_;

// time of last stepper step
static double last_step_time_ = 0.0;

// turn on/off debug mode for this file only
constexpr static bool debug_ = false; 

/* ----- initialising, setup, and utilities ----- */

void init(mjModel* model, mjData* data)
{
  /* runs once when model is created */

  last_step_time_ = 0.0;

  // set the model to the inital keyframe
  keyframe(model, data, j_.initial_keyframe);

  // calculate all object positions/forces
  mj_forward(model, data);

  // extract model information and store it in our global variable j_
  init_J(model, data);

  // initialise the object handler
  oh_.init(model, data);

  // // assign my control function to the mujoco control fcn pointer
  // mjcb_control = control;
}

void init_J(mjModel* model, mjData* data)
{
  /* initialise our global data structure with joint and model information */

  // wipe the global settings structure
  j_.reset();

  // use joint names to get body indexes and qpos/qvel addresses
  get_joint_indexes(model);
  get_joint_addresses(model);
  get_geom_indexes(model);
  get_segment_matrices(model, data);

  if (debug_) {
    print_joint_names(model);
  }

  // resize state vectors and find qpos/qvel pointers
  configure_qpos(model, data);

  // calculate constants
  j_.ctrl.time_per_step = j_.ctrl.num_steps / j_.ctrl.pulses_per_s;
  int N = j_.num.per_finger;
  int Ntotal = j_.num.per_finger + j_.dim.fixed_first_segment;
  j_.dim.segment_length = j_.dim.finger_length / float(Ntotal);

  if (j_.dim.fixed_first_segment) {
    j_.dim.stiffness_c = ( j_.dim.EI / (2 * j_.dim.finger_length) ) 
      * ( (float)(N * (N*N + 6*N + 11)) / (float)((N + 1) * (N + 1)) );
  }
  else {
    j_.dim.stiffness_c = ( j_.dim.EI / (2 * j_.dim.finger_length) ) 
       * ( (float)((N + 1)*(N + 2)) / N);
  }

  if (debug_) {
    std::cout << "Number of finger joints N is " << j_.num.per_finger << '\n';
    std::cout << "Joint stiffness c is " << j_.dim.stiffness_c << '\n';
  }

  configure_constraints(model, data);
}

void reset(mjModel* model, mjData* data)
{
  /* reset the simulation */

  // reset the targets and disable any constraints
  target_.reset();
  wipe_segment_forces();
  set_all_constraints(model, data, false);

  // wipe object positions and reset
  mj_resetData(model, data);
  keyframe(model, data, j_.reset_keyframe);
  reset_object(model, data);

  // recalculate all object positions/forces
  mj_forward(model, data);
  update_all(model, data);

  // set the joints to the equilibrium position
  calibrate_reset(model, data);

  // now enable all constraints at equilibrium position
  set_all_constraints(model, data, true);
}

void print_joint_names(mjModel* model)
{
  /* print joint names to the terminal */

  for (int i = 0; i < model->njnt; i++) {
    auto x = mj_id2name(model, mjOBJ_JOINT, i);
    std::cout << "i = " << i << " gives jnt name = " << x << '\n';
  }
}

void get_joint_indexes(mjModel* model)
{
  /* Get the indexes of the different joint groups */

  for (std::string name : j_.names.panda) {
    int idx = mj_name2id(model, mjOBJ_JOINT, name.c_str());
    j_.idx.panda.push_back(idx);
  }
  for (std::string name : j_.names.gripper) {
    int idx = mj_name2id(model, mjOBJ_JOINT, name.c_str());
    j_.idx.gripper.push_back(idx);
  }
  for (std::string name : j_.names.base) {
    int idx = mj_name2id(model, mjOBJ_JOINT, name.c_str());
    j_.idx.base.push_back(idx);
  }

  if (j_.idx.panda[0] != -1) j_.in_use.panda = true;
  else j_.in_use.panda = false;

  if (j_.idx.gripper[0] != -1) j_.in_use.gripper = true;
  else j_.in_use.gripper = false;

  if (j_.idx.base[0] != -1) j_.in_use.base = true;
  else j_.in_use.base = false;

  // determine how many joints are being used for each part
  j_.num.panda = j_.names.panda.size() * j_.in_use.panda;
  j_.num.gripper = j_.names.gripper.size() * j_.in_use.gripper;
  j_.num.base = j_.names.base.size() * j_.in_use.base;

  // count how many segment joints we have
  j_.num.finger = 0;
  j_.dim.fixed_first_segment = true;
  j_.dim.fixed_hook_segment = true;
  for (int i = 0; i < model->njnt; i++) {
    std::string x = mj_id2name(model, mjOBJ_JOINT, i);
    if (x.substr(0,6) == "finger" and x.substr(9, 13) == "segment_joint") {
      j_.num.finger += 1;
      // if we have a segment_joint_0 then there is not a fixed first joint
      if (x.substr(9, 15) == "segment_joint_0") {
        j_.dim.fixed_first_segment = false;
      }
    }
    // if we have a hook_joint then there is no fixed hook joint
    if (x.substr(9, 17) == "finger_hook_joint") {
      j_.dim.fixed_hook_segment = false;
    }
  }

  // // for testing
  // if (j_.num.finger != 27) throw std::runtime_error("j_.num.finger != 27");

  // hence per finger is this divided by 3
  j_.num.per_finger = j_.num.finger / 3;

  if (j_.num.finger > 0) {

    j_.in_use.finger = true;
    int ffs = (int) j_.dim.fixed_first_segment;

    // add the names of every finger joint to the global vector
    for (int i = 1; i <= 3; i++) {
      for (int k = ffs; k < j_.num.per_finger + ffs; k++) {
        // create the joint name string and add it to the vector
        std::string next = "finger_" + std::to_string(i)
          + "_segment_joint_" + std::to_string(k);
        j_.names.finger.push_back(next);
      }
    }

    // now, we want the indexes corresponding to each joint
    for (std::string name : j_.names.finger) {
      int idx = mj_name2id(model, mjOBJ_JOINT, name.c_str());
      j_.idx.finger.push_back(idx);
    }

    // extra safety check
    if (j_.names.finger.size() == 0 or j_.idx.finger[0] == -1) {
      printf("Error: Finger joints not found\n");
      j_.in_use.finger = false;
      j_.num.finger = 0;
    }
  }

  if (debug_) {
    j_.print_in_use();
    j_.print_num();
    j_.print_idx();
    std::cout << "Fixed first segment is: " << j_.dim.fixed_first_segment << '\n';
    std::cout << "Fixed hook segment is: " << j_.dim.fixed_hook_segment << '\n';
  }
}

void get_geom_indexes(mjModel* model)
{
  /* get the indexes of the geoms for the fingers */

  // each geom has both a 'collision' and 'visual' version, so we collect both
  std::vector<std::string> geom_suffixes { "collision", "visual" };

  int ffs = j_.dim.fixed_first_segment;

  for (std::string geom_tag : geom_suffixes) {

    for (int i = 0; i < j_.num.finger; i++) {

      std::string geom_name = "finger_" + std::to_string(i / j_.num.per_finger + 1)  // finger_X, X=1,2,3
        + "_segment_link_" + std::to_string(i % j_.num.per_finger + 1 + ffs)         // links go 2-10 for 10 segments
        + "_geom_" + geom_tag;

      int x = mj_name2id(model, mjOBJ_GEOM, geom_name.c_str());

      if (i < j_.num.per_finger) {
        j_.geom_idx.finger1.push_back(x);
      }
      else if (i < 2 * j_.num.per_finger) {
        j_.geom_idx.finger2.push_back(x);
      }
      else if (i < 3 * j_.num.per_finger) {
        j_.geom_idx.finger3.push_back(x);
      }
      else {
        throw std::runtime_error("get_geom_indexes() found inconsistent finger segment numbers");
      }
    }

    // now add the hook links
    std::string f1_hook = "finger_1_segment_link_" + std::to_string(j_.num.per_finger + ffs)
      + "_geom_hook_" + geom_tag;
    std::string f2_hook = "finger_2_segment_link_" + std::to_string(j_.num.per_finger + ffs)
      + "_geom_hook_" + geom_tag;
    std::string f3_hook = "finger_3_segment_link_" + std::to_string(j_.num.per_finger + ffs)
      + "_geom_hook_" + geom_tag;

    j_.geom_idx.finger1.push_back(mj_name2id(model, mjOBJ_GEOM, f1_hook.c_str()));
    j_.geom_idx.finger2.push_back(mj_name2id(model, mjOBJ_GEOM, f2_hook.c_str()));
    j_.geom_idx.finger3.push_back(mj_name2id(model, mjOBJ_GEOM, f3_hook.c_str()));

    // now add the palm link
    std::string palm_geom_name = "palm_geom_" + geom_tag;
    j_.geom_idx.palm.push_back(mj_name2id(model, mjOBJ_GEOM, palm_geom_name.c_str()));
  }

  if (debug_) {
    j_.print_geom_idx();
  }
}

void get_joint_addresses(mjModel* model)
{
  /* Get the qpos and qvel addresses for each active joint */

  // old (incorrect) code used: model->jnt_qposadr[model->body_jntadr[idx]]

  if (j_.in_use.panda) {
    for (int idx : j_.idx.panda) {
      j_.qposadr.panda.push_back(model->jnt_qposadr[idx]);
      j_.qveladr.panda.push_back(model->jnt_dofadr[idx]);
    }
  }

  if (j_.in_use.gripper) {
    for (int idx : j_.idx.gripper) {
      j_.qposadr.gripper.push_back(model->jnt_qposadr[idx]);
      j_.qveladr.gripper.push_back(model->jnt_dofadr[idx]);
    }
  }

  if (j_.in_use.finger) {
    for (int idx : j_.idx.finger) {
      j_.qposadr.finger.push_back(model->jnt_qposadr[idx]);
      j_.qveladr.finger.push_back(model->jnt_dofadr[idx]);
    }
  }

  if (j_.in_use.base) {
    for (int idx : j_.idx.base) {
      j_.qposadr.base.push_back(model->jnt_qposadr[idx]);
      j_.qveladr.base.push_back(model->jnt_dofadr[idx]);
    }
  }

  if (debug_) {
    j_.print_qposadr();
    j_.print_qveladr();
  }
}

bool change_finger_thickness(float thickness)
{
  /* set a new finger thickness, and correspondingly change EI, requires reset after 
  to set new finger stiffnesses */

  constexpr bool local_debug = debug_;

  if (local_debug) {
    std::cout << "About to change finger thickness from " << j_.dim.finger_thickness
      << " to " << thickness << ", EI is " << j_.dim.EI << '\n';
  }

  // check if thickness is greater than 5mm
  if (thickness > 2e-3) {
    std::cout << "thickness given = " << thickness << '\n';
    throw std::runtime_error("change_finger_thickness() got value above 2mm - make sure you are using SI units!");
  }

  constexpr float tol = 1e-5;

  if (abs(thickness - j_.dim.finger_thickness) < tol) {
    if (local_debug) std::cout << "Finger thickness is the same as current, not changing\n";
    return false;
  }

  j_.dim.finger_thickness = thickness;
  j_.dim.I = (j_.dim.finger_width * std::pow(j_.dim.finger_thickness, 3)) / 12.0;
  j_.dim.EI = j_.dim.E * j_.dim.I;

  if (local_debug) {
    std::cout << "Finger thickness changed, now is " << j_.dim.finger_thickness
      << ", EI is " << j_.dim.EI << '\n';
  }

  return true;
}

bool change_finger_width(float width)
{
  /* set a new finger wdith, and correspondingly change EI, no reset required, but
  the loaded urdf should be changed if the width changes which would require a hard_reset */

  constexpr bool local_debug = debug_;

  if (local_debug) {
    std::cout << "About to change finger width from " << j_.dim.finger_width
      << " to " << width << ", EI is " << j_.dim.EI << '\n';
  }

  // check if thickness is greater than 1 metre
  if (width > 1) {
    std::cout << "width given = " << width << '\n';
    throw std::runtime_error("change_finger_width() got value above 1 metre - make sure you are using SI units!");
  }

  constexpr float tol = 1e-5;

  if (abs(width - j_.dim.finger_width) < tol) {
    if (local_debug) std::cout << "Finger width is the same as current, not changing\n";
    return false;
  }

  j_.dim.finger_width = width;
  j_.dim.I = (j_.dim.finger_width * std::pow(j_.dim.finger_thickness, 3)) / 12.0;
  j_.dim.EI = j_.dim.E * j_.dim.I;

  if (local_debug) {
    std::cout << "Finger width changed, now is " << j_.dim.finger_width
      << ", EI is " << j_.dim.EI << '\n';
  }

  return true;
}

void set_finger_stiffness(mjModel* model, std::vector<luke::gfloat> stiffness)
{
  /* set the finger stiffness to a vector sequence of values */

  constexpr bool local_debug = debug_;
  
  int N = j_.num.per_finger;

  if (stiffness.size() != N) {
    throw std::runtime_error("wrong number of joint stiffnesses passed to set_finger_stiffness(...)");
  }

  // loop over all three fingers
  for (int i = 0; i < 3; i++) {

    // loop from n=1 to N
    for (int n = 1; n < N + 1; n++) {

      int idx = j_.idx.finger[i * N + (n - 1)];

      if (local_debug and i == 0) 
        std::cout << "Finger joint stiffness joint " << i << " is " << stiffness[n - 1] << '\n';

      if (i == 0) {
        j_.dim.joint_stiffness[n - 1] = stiffness[n - 1];
      }

      model->jnt_stiffness[idx] = stiffness[n - 1];

    }
  }
}

void set_finger_stiffness(mjModel* model, mjtNum stiffness)
{
  /* set the stiffness of the flexible finger joints. The input value for stiffness
  determines the behaviour of this function.

  INPUT OPTIONS
  stiffness > 0       -> all joints are set to this stiffness value
  stiffness is -7.5   -> stiffness is calculated with finalised theory derviation
  stiffness is -100   -> use hardcoded stiffness values, convergence on real data (only 0.9mm bending @ 300g)
  stiffness is -101   -> use hardcoded stiffness values, convergence on theory (0.8/0.9/1.0mm @ 300g)
  stiffness is -102   -> use hardcoded stiffness values, testing area

  */

  // macro for hardcoding stiffness values
  #define LUKE_EXPAND_HARDCODED_STIFFNESSES(NAME) \
                switch (N) { \
                  case 3:  set_finger_stiffness(model, j_.hardcoded_c.NAME.N3); break; \
                  case 4:  set_finger_stiffness(model, j_.hardcoded_c.NAME.N4); break; \
                  case 5:  set_finger_stiffness(model, j_.hardcoded_c.NAME.N5); break; \
                  case 6:  set_finger_stiffness(model, j_.hardcoded_c.NAME.N6); break; \
                  case 7:  set_finger_stiffness(model, j_.hardcoded_c.NAME.N7); break; \
                  case 8:  set_finger_stiffness(model, j_.hardcoded_c.NAME.N8); break; \
                  case 9:  set_finger_stiffness(model, j_.hardcoded_c.NAME.N9); break; \
                  case 10: set_finger_stiffness(model, j_.hardcoded_c.NAME.N10); break; \
                  case 11: set_finger_stiffness(model, j_.hardcoded_c.NAME.N11); break; \
                  case 12: set_finger_stiffness(model, j_.hardcoded_c.NAME.N12); break; \
                  case 13: set_finger_stiffness(model, j_.hardcoded_c.NAME.N13); break; \
                  case 14: set_finger_stiffness(model, j_.hardcoded_c.NAME.N14); break; \
                  case 15: set_finger_stiffness(model, j_.hardcoded_c.NAME.N15); break; \
                  case 16: set_finger_stiffness(model, j_.hardcoded_c.NAME.N16); break; \
                  case 17: set_finger_stiffness(model, j_.hardcoded_c.NAME.N17); break; \
                  case 18: set_finger_stiffness(model, j_.hardcoded_c.NAME.N18); break; \
                  case 19: set_finger_stiffness(model, j_.hardcoded_c.NAME.N19); break; \
                  case 20: set_finger_stiffness(model, j_.hardcoded_c.NAME.N20); break; \
                  case 21: set_finger_stiffness(model, j_.hardcoded_c.NAME.N21); break; \
                  case 22: set_finger_stiffness(model, j_.hardcoded_c.NAME.N22); break; \
                  case 23: set_finger_stiffness(model, j_.hardcoded_c.NAME.N23); break; \
                  case 24: set_finger_stiffness(model, j_.hardcoded_c.NAME.N24); break; \
                  case 25: set_finger_stiffness(model, j_.hardcoded_c.NAME.N25); break; \
                  case 26: set_finger_stiffness(model, j_.hardcoded_c.NAME.N26); break; \
                  case 27: set_finger_stiffness(model, j_.hardcoded_c.NAME.N27); break; \
                  case 28: set_finger_stiffness(model, j_.hardcoded_c.NAME.N28); break; \
                  case 29: set_finger_stiffness(model, j_.hardcoded_c.NAME.N29); break; \
                  case 30: set_finger_stiffness(model, j_.hardcoded_c.NAME.N30); break; \
                  default: \
                    std::string error_string = "no hardcoded theory stiffness values for this N = "; \
                    error_string += std::to_string(N); \
                    throw std::runtime_error(error_string); \
                }

  // start of function proper
  constexpr bool local_debug = debug_;

  int N = j_.num.per_finger;

  // prepare a convenience vector to record stiffness values for each finger
  j_.dim.joint_stiffness.clear();
  j_.dim.joint_stiffness.resize(N);

  if (stiffness > 0) {
    if (local_debug) std::cout << "Finger joint stiffness ALL set to " << stiffness << '\n';
    for (int i : j_.idx.finger) {
      model->jnt_stiffness[i] = stiffness;
    }
    // save stiffness values for one finger, even though they are all the same
    for (int i = 0; i < N; i++) j_.dim.joint_stiffness[i] = stiffness;
  }

  else if (stiffness > -8 and stiffness < -7) {

    if (local_debug) std::cout << "Finger joint stiffness set using finalised theory method (EI*N)/L\n";

    // loop over all three fingers
    for (int i = 0; i < 3; i++) {

      float angle_sum = 0;

      // loop from n=1 to N
      for (int n = 1; n < N + 1; n++) {

        int idx = j_.idx.finger[i * N + (n - 1)];

        // calculate the stiffness for each joint
        float c;
        if (n == 1) {
          c = ((2 * j_.dim.EI) / j_.dim.finger_length) * ((N*N) / (double)(N - (1.0/3.0)));
        }
        else {
          c = (N * j_.dim.EI) / j_.dim.finger_length;
        }

        // save stiffness values for 1st finger
        if (i == 0) {
          j_.dim.joint_stiffness[n - 1] = c;
        }

        if (local_debug and i == 0) {
          std::cout << "finger joint " << n << " has c_n = " << c << '\n';
        }

        model->jnt_stiffness[idx] = c;
      }
    }
  }

  else if (stiffness > -100.5 and stiffness < -99.5) {

    if (local_debug) std::cout << "Finger joint stiffness set using hardcoding for 235x28x0.9mm fingers from real data\n";

    switch (N) {

      case 5:  set_finger_stiffness(model, j_.hardcoded_c.finger_235x28x0p9.N5); break;
      case 6:  set_finger_stiffness(model, j_.hardcoded_c.finger_235x28x0p9.N6); break;
      case 7:  set_finger_stiffness(model, j_.hardcoded_c.finger_235x28x0p9.N7); break;
      case 8:  set_finger_stiffness(model, j_.hardcoded_c.finger_235x28x0p9.N8); break;
      case 9:  set_finger_stiffness(model, j_.hardcoded_c.finger_235x28x0p9.N9); break;
      case 10: set_finger_stiffness(model, j_.hardcoded_c.finger_235x28x0p9.N10); break;
      case 15: set_finger_stiffness(model, j_.hardcoded_c.finger_235x28x0p9.N15); break;
      case 20: set_finger_stiffness(model, j_.hardcoded_c.finger_235x28x0p9.N20); break;
      case 25: set_finger_stiffness(model, j_.hardcoded_c.finger_235x28x0p9.N25); break;
      case 30: set_finger_stiffness(model, j_.hardcoded_c.finger_235x28x0p9.N30); break;

      default:
        std::cout << "N is " << N << '\n';
        throw std::runtime_error("no hardcoded stiffness values for this N");
    }

  }

  else if (stiffness > -101.5 and stiffness < -100.5) {

    float tol = 1e-5;

    if (local_debug) std::cout << "Finger joint stiffnesses set using hardcoding from theory predictions, ";

    // finger thickness 0.8mm
    if (abs(j_.dim.finger_thickness - 0.8e-3) < tol) {

      // finger width 28mm
      if (abs(j_.dim.finger_width - 28e-3) < tol) {
        if (local_debug) std::cout << "finger length=235, width=28, thickness=0.8\n";
        LUKE_EXPAND_HARDCODED_STIFFNESSES(theory_235x28x0p8)
      }
      else {
        std::cout << "finger width is " << j_.dim.finger_width << '\n';
        throw std::runtime_error("no hardcoded theory stiffness values for this finger width");
      }
    }

    // finger thickness 0.9mm
    else if (abs(j_.dim.finger_thickness - 0.9e-3) < tol) {

      // finger width 28mm
      if (abs(j_.dim.finger_width - 28e-3) < tol) {
        if (local_debug) std::cout << "finger length=235, width=28, thickness=0.9\n";
        LUKE_EXPAND_HARDCODED_STIFFNESSES(theory_235x28x0p9)
      }
      // finger width 24mm
      else if (abs(j_.dim.finger_width - 24e-3) < tol) {
        if (local_debug) std::cout << "finger length=235, width=24, thickness=0.9\n";
        LUKE_EXPAND_HARDCODED_STIFFNESSES(theory_235x24x0p9)
      }
      else {
        std::cout << "finger width is " << j_.dim.finger_width << '\n';
        throw std::runtime_error("no hardcoded theory stiffness values for this finger width");
      }
    }

    // finger thickness 1.0mm
    else if (abs(j_.dim.finger_thickness - 1.0e-3) < tol) {

      // finger width 28mm
      if (abs(j_.dim.finger_width - 28e-3) < tol) {
        if (local_debug) std::cout << "finger length=235, width=28, thickness=1.0\n";
        LUKE_EXPAND_HARDCODED_STIFFNESSES(theory_235x28x1p0)
      }
      // finger width 24mm
      else if (abs(j_.dim.finger_width - 24e-3) < tol) {
        if (local_debug) std::cout << "finger length=235, width=24, thickness=1.0\n";
        LUKE_EXPAND_HARDCODED_STIFFNESSES(theory_235x24x1p0)
      }
      else {
        std::cout << "finger width is " << j_.dim.finger_width << '\n';
        throw std::runtime_error("no hardcoded theory stiffness values for this finger width");
      }
    }

    else {
      std::cout << "finger thickness is " << j_.dim.finger_thickness << '\n';
      throw std::runtime_error("no hardcoded theory stiffness values for this finger thickness");
    }
  }

  else {
    std::cout << "set_finger_stiffness(...) input stiffness was " << stiffness << '\n';
    throw  std::runtime_error("set_finger_stiffness(...) input stiffness not valid");
  }

  if (local_debug)
    print_vec(j_.dim.joint_stiffness, "joint stiffness vector");
}

void configure_qpos(mjModel* model, mjData* data)
{
  /* sort out qpos and qvel information */

  // resize state vectors
  j_.qpos.panda.resize(j_.num.panda);
  j_.qpos.gripper.resize(j_.num.gripper);
  j_.qpos.finger.resize(j_.num.finger);
  j_.qpos.base.resize(j_.num.base);

  j_.qvel.panda.resize(j_.num.panda);
  j_.qvel.gripper.resize(j_.num.gripper);
  j_.qvel.finger.resize(j_.num.finger);
  j_.qvel.base.resize(j_.num.base);

  // resize pointer vectors
  j_.to_qpos.panda.resize(j_.num.panda);
  j_.to_qpos.gripper.resize(j_.num.gripper);
  j_.to_qpos.finger.resize(j_.num.finger);
  j_.to_qpos.base.resize(j_.num.base);

  j_.to_qvel.panda.resize(j_.num.panda);
  j_.to_qvel.gripper.resize(j_.num.gripper);
  j_.to_qvel.finger.resize(j_.num.finger);
  j_.to_qvel.base.resize(j_.num.base);

  // insert the pointers
  if (j_.in_use.panda) {
    for (int i = 0; i < j_.num.panda; i++) {
      j_.to_qpos.panda[i] = &data->qpos[j_.qposadr.panda[i]];
      j_.to_qvel.panda[i] = &data->qvel[j_.qveladr.panda[i]];
    }
  }

  if (j_.in_use.gripper) {
    for (int i = 0; i < j_.num.gripper; i++) {
      j_.to_qpos.gripper[i] = &data->qpos[j_.qposadr.gripper[i]];
      j_.to_qvel.gripper[i] = &data->qvel[j_.qveladr.gripper[i]];
    }
  }
  
  if (j_.in_use.finger) {
    for (int i = 0; i < j_.num.finger; i++) {
      j_.to_qpos.finger[i] = &data->qpos[j_.qposadr.finger[i]];
      j_.to_qvel.finger[i] = &data->qvel[j_.qveladr.finger[i]];
    }
  }

  if (j_.in_use.base) {
    for (int i = 0; i < j_.num.base; i++) {
      j_.to_qpos.base[i] = &data->qpos[j_.qposadr.base[i]];
      j_.to_qvel.base[i] = &data->qvel[j_.qveladr.base[i]];
    }
  }
}

void configure_constraints(mjModel* model, mjData* data)
{
  /* configure equality constraints for gripper motors */

  constexpr char pris_b1[] = "gripper_base_link";
  constexpr char pris_b2[] = "finger_{X}_intermediate";
  constexpr char rev_b1[] = "finger_{X}_intermediate";
  constexpr char rev_b2[] = "finger_{X}";
  constexpr char palm_b1[] = "gripper_base_link";
  constexpr char palm_b2[] = "palm";

  for (int i = 0; i < model->neq; i++) {

    std::string name1 = mj_id2name(model, mjOBJ_BODY, model->eq_obj1id[i]);
    std::string name2 = mj_id2name(model, mjOBJ_BODY, model->eq_obj2id[i]);


    if (debug_) {
      std::printf("Constraint %d has ids %d and %d, which are bodies %s and %s\n", 
        i, model->eq_obj1id[i], model->eq_obj2id[i], name1.c_str(), name2.c_str());
    }

    // detect if it is a prismatic joint constraint
    if ((strcmp_w_sub(name1, pris_b1, 3) or strcmp_w_sub(name1, pris_b2, 3)) and
        (strcmp_w_sub(name2, pris_b1, 3) or strcmp_w_sub(name2, pris_b2, 3))) {
      j_.con_idx.prismatic.push_back(i);
    }

    // detect if it is a revolute joint constraint
    if ((strcmp_w_sub(name1, rev_b1, 3) or strcmp_w_sub(name1, rev_b2, 3)) and
        (strcmp_w_sub(name2, rev_b1, 3) or strcmp_w_sub(name2, rev_b2, 3))) {
      j_.con_idx.revolute.push_back(i);
    }

    // detect if it is a palm joint constraint
    if ((strcmp_w_sub(name1, palm_b1, 3) or strcmp_w_sub(name1, palm_b2, 3)) and
        (strcmp_w_sub(name2, palm_b1, 3) or strcmp_w_sub(name2, palm_b2, 3))) {
      j_.con_idx.palm.push_back(i);
    }

    // set constraint to default value of false
    model->eq_active[i] = false;
  }

  if (debug_) {
    print_vec(j_.con_idx.prismatic, "prismatic joint constraints");
    print_vec(j_.con_idx.revolute, "revolute joint constraints");
    print_vec(j_.con_idx.palm, "palm joint constraints");
  }
}

void set_all_constraints(mjModel* model, mjData* data, bool set_to)
{
  /* reset all constraints to false */

  for (int i : j_.con_idx.prismatic) {
    set_constraint(model, data, i, set_to);
  }
  for (int i : j_.con_idx.revolute) {
    set_constraint(model, data, i, set_to);
  }
  for (int i : j_.con_idx.palm) {
    set_constraint(model, data, i, set_to);
  }
}

void toggle_constraint(mjModel* model, mjData* data, int id)
{
  set_constraint(model, data, id, not model->eq_active[id]);
}

void set_constraint(mjModel* model, mjData* data, int id, bool set_as)
{
  /* toggle a constraint, if active lock the body in place relative to another */

  if (set_as) {

    // prepare and get indexes of position/rotation data
    mjtNum body1_pos[3];
    mjtNum body2_pos[3];
    mjtNum body1_rot[9];
    mjtNum body2_rot[9];
    int con_id = id * mjNEQDATA; // index where we insert constraint data
    int b1_pos_id = model->eq_obj1id[id] * 3;
    int b2_pos_id = model->eq_obj2id[id] * 3;
    int b1_rot_id = model->eq_obj1id[id] * 9;
    int b2_rot_id = model->eq_obj2id[id] * 9;

    // get the global rotation of the two bodies
    for (int i = 0; i < 9; i++) {
      body1_rot[i] = data->xmat[b1_rot_id + i];
      body2_rot[i] = data->xmat[b2_rot_id + i];
    }

    // get the global position of the two bodies
    for (int i = 0; i < 3; i++) {
      body1_pos[i] = data->xpos[b1_pos_id + i];
      body2_pos[i] = data->xpos[b2_pos_id + i];
    }

    // now find the local rotation, R12 = (R01)^T * R02
    mjtNum R12[9];
    mju_mulMatTMat(R12, body1_rot, body2_rot, 3, 3, 3);

    // subract the vectors from each other, then rotate into frame 1 (from 0)
    mjtNum vdiff[3];
    mjtNum vec12[3];
    vdiff[0] = body2_pos[0] - body1_pos[0];
    vdiff[1] = body2_pos[1] - body1_pos[1];
    vdiff[2] = body2_pos[2] - body1_pos[2];
    mju_mulMatVec(vec12, body1_rot, vdiff, 3, 3);

    // convert local rotation into a quaternion
    mjtNum quat12[4];
    mju_mat2Quat(quat12, R12);

    // insert this info into the constraint
    model->eq_data[con_id + 0] = vec12[0];
    model->eq_data[con_id + 1] = vec12[1];
    model->eq_data[con_id + 2] = vec12[2];
    model->eq_data[con_id + 3] = quat12[0];
    model->eq_data[con_id + 4] = quat12[1];
    model->eq_data[con_id + 5] = quat12[2];
    model->eq_data[con_id + 6] = quat12[3];

    // activate the constraint
    set_as = true;

    /* for testing
    std::cout << "Body 1 position is: ";
    for (int i = 0; i < 3; i++) {
      std::cout << body1_pos[i] << ", ";
    }
    std::cout << '\n';
    std::cout << "Body 2 position is: ";
    for (int i = 0; i < 3; i++) {
      std::cout << body2_pos[i] << ", ";
    }
    std::cout << '\n';
    std::cout << "Body 1 rotation is: ";
    mjtNum b1Quat[4];
    mju_mat2Quat(b1Quat, body1_rot);
    for (int i = 0; i < 4; i++) {
      std::cout << b1Quat[i] << ", ";
    }
    std::cout << '\n';
    std::cout << "Body 2 rotation is: ";
    mjtNum b2Quat[4];
    mju_mat2Quat(b2Quat, body2_rot);
    for (int i = 0; i < 4; i++) {
      std::cout << b2Quat[i] << ", ";
    }
    std::cout << '\n';
    std::cout << "Constraint data is: ";
    for (int i = 0; i < 7; i++) {
      std::cout << model->eq_data[con_id + i] << ", ";
    }
    std::cout << "\n\n";
    */
    
  }

  // set the constraint either active or inactive
  model->eq_active[id] = set_as;
}

void target_constraint(mjModel* model, mjData* data, int id, bool set_as, int type)
{
  /* set a constraint to send a motor to a target position */

  /* THIS FUNCTION IS UNFINISHED AND NOT CURRENTLY IN USE */

  if (set_as) {

    // int con_id = id * mjNEQDATA; // index where we insert constraint data

    // prepare and get indexes of position/rotation data
    mjtNum body1_pos[3];
    mjtNum body2_pos[3];
    mjtNum body1_rot[9];
    mjtNum body2_rot[9];
    int con_id = id * mjNEQDATA; // index where we insert constraint data
    int b1_pos_id = model->eq_obj1id[id] * 3;
    int b2_pos_id = model->eq_obj2id[id] * 3;
    int b1_rot_id = model->eq_obj1id[id] * 9;
    int b2_rot_id = model->eq_obj2id[id] * 9;

    // get the global rotation of the two bodies
    for (int i = 0; i < 9; i++) {
      body1_rot[i] = data->xmat[b1_rot_id + i];
      body2_rot[i] = data->xmat[b2_rot_id + i];
    }

    // get the global position of the two bodies
    for (int i = 0; i < 3; i++) {
      body1_pos[i] = data->xpos[b1_pos_id + i];
      body2_pos[i] = data->xpos[b2_pos_id + i];
    }

    // now find the local rotation, R12 = (R01)^T * R02
    mjtNum R12[9];
    mju_mulMatTMat(R12, body1_rot, body2_rot, 3, 3, 3);

    // subract the vectors from each other, then rotate into frame 1 (from 0)
    mjtNum vdiff[3];
    mjtNum vec12[3];
    vdiff[0] = body2_pos[0] - body1_pos[0];
    vdiff[1] = body2_pos[1] - body1_pos[1];
    vdiff[2] = body2_pos[2] - body1_pos[2];
    mju_mulMatVec(vec12, body1_rot, vdiff, 3, 3);

    // convert local rotation into a quaternion
    mjtNum quat12[4];
    mju_mat2Quat(quat12, R12);

    // insert this info into the constraint
    model->eq_data[con_id + 0] = vec12[0];
    model->eq_data[con_id + 1] = vec12[1];
    model->eq_data[con_id + 2] = vec12[2];
    model->eq_data[con_id + 3] = quat12[0];
    model->eq_data[con_id + 4] = quat12[1];
    model->eq_data[con_id + 5] = quat12[2];
    model->eq_data[con_id + 6] = quat12[3];

    // gripper prismatic
    if (type == 0) {
      model->eq_data[con_id + 0] = 0;
      model->eq_data[con_id + 1] = target_.end.x;
      model->eq_data[con_id + 2] = 0;
      model->eq_data[con_id + 3] = 0;
      model->eq_data[con_id + 4] = 0;
      model->eq_data[con_id + 5] = 0;
      model->eq_data[con_id + 6] = 1;
    }

    // // gripper revolute
    // else if (type == 1) {
    //   float axis[3] = { 0, 0, -1 };
    //   float half_angle = 0.5 * target_.end.get_revolute_joint();
    //   model->eq_data[con_id + 0] = 0;
    //   model->eq_data[con_id + 1] = 0;
    //   model->eq_data[con_id + 2] = 0;
    //   model->eq_data[con_id + 3] = axis[0] * std::sin(half_angle);
    //   model->eq_data[con_id + 4] = axis[1] * std::sin(half_angle);
    //   model->eq_data[con_id + 5] = axis[2] * std::sin(half_angle);
    //   model->eq_data[con_id + 6] = std::cos(half_angle);
    // }

    // // gripper palm
    // else if (type == 2) {
    //   model->eq_data[con_id + 0] = target_.end.z;
    //   model->eq_data[con_id + 1] = 0;
    //   model->eq_data[con_id + 2] = 0;
    //   model->eq_data[con_id + 3] = 0;
    //   model->eq_data[con_id + 4] = 0;
    //   model->eq_data[con_id + 5] = 0;
    //   model->eq_data[con_id + 6] = 1;
    // }

    /* for testing */
    std::cout << "Body 1 position is: ";
    for (int i = 0; i < 3; i++) {
      std::cout << body1_pos[i] << ", ";
    }
    std::cout << '\n';
    std::cout << "Body 2 position is: ";
    for (int i = 0; i < 3; i++) {
      std::cout << body2_pos[i] << ", ";
    }
    std::cout << '\n';
    std::cout << "Body 1 rotation is: ";
    mjtNum b1Quat[4];
    mju_mat2Quat(b1Quat, body1_rot);
    for (int i = 0; i < 4; i++) {
      std::cout << b1Quat[i] << ", ";
    }
    std::cout << '\n';
    std::cout << "Body 2 rotation is: ";
    mjtNum b2Quat[4];
    mju_mat2Quat(b2Quat, body2_rot);
    for (int i = 0; i < 4; i++) {
      std::cout << b2Quat[i] << ", ";
    }
    std::cout << '\n';
    std::cout << "Constraint data is: ";
    for (int i = 0; i < 7; i++) {
      std::cout << model->eq_data[con_id + i] << ", ";
    }
    std::cout << "\n\n";
    
  }

  // set the constraint either active or inactive
  model->eq_active[id] = set_as;
}

void keyframe(mjModel* model, mjData* data, std::string keyframe_name)
{
  /* overload with keyframe name */

  // set model to keyframe with the given name
  int key = mj_name2id(model, mjOBJ_KEY, keyframe_name.c_str());

  keyframe(model, data, key);
}

void keyframe(mjModel* model, mjData* data, int key)
{
  /* to run once to initialise the model to a desired state.
  Code is adapted from testspeed.cc line 117 */

  if (key >= 0) {
    data->time = model->key_time[key];
    mju_copy(data->qpos, model->key_qpos + key * model->nq, model->nq);
    mju_copy(data->qvel, model->key_qvel + key * model->nv, model->nv);
    mju_copy(data->act, model->key_act + key * model->na, model->na);
    // mju_copy(d->mocap_pos, m->key_mpos+i*3*m->nmocap, 3*m->nmocap);
		// mju_copy(d->mocap_quat, m->key_mquat+i*4*m->nmocap, 4*m->nmocap);
  }
  else {
    throw std::runtime_error("keyframe does not exist");
  }

  last_step_time_ = model->key_time[key];
}

void calibrate_reset(mjModel* model, mjData* data)
{
  /* find the equilibrium start position and set the simulation to that */

  static bool first_call = true;
  static std::vector<mjtNum> control_signals;
  static std::vector<mjtNum> qpos_positions;

  if (first_call) {

    constexpr int settle_number = 400; // found using mysimulate and visual inspection

    // loop to settle the simulation ~86ms
    for (int i = 0; i < settle_number; i++) {
      before_step(model, data);
      step(model, data);
      after_step(model, data);
    }

    // see where the joints have settled to equilibrium
    for (int i = 0; i < j_.num.panda; i++) {
      qpos_positions.push_back(*j_.to_qpos.panda[i]);
    }

    for (int i = 0; i < j_.num.base; i++) {
      qpos_positions.push_back(*j_.to_qpos.base[i]);
    }

    for (int i = 0; i < j_.num.gripper; i++) {
      qpos_positions.push_back(*j_.to_qpos.gripper[i]);
    }

    first_call = false;
  }

  int k = 0;

  // apply the equilibrium positions to the joints
  for (int i = 0; i < j_.num.panda; i++) { 
    (*j_.to_qpos.panda[i]) = qpos_positions[k]; 
    k += 1;
  }

  for (int i = 0; i < j_.num.base; i++) {
    (*j_.to_qpos.base[i]) = qpos_positions[k]; 
    k += 1;
  }

  for (int i = 0; i < j_.num.gripper; i++) {
    (*j_.to_qpos.gripper[i]) = qpos_positions[k]; 
    k += 1;
  }

}

void get_segment_matrices(mjModel* model, mjData* data)
{
  /* find the matrix orientation for each of the segments of the fingers */

  j_.segmentMatrices.f1_idx.clear();
  j_.segmentMatrices.f2_idx.clear();
  j_.segmentMatrices.f3_idx.clear();

  // get the name of the last finger link (hook link is removed by mujoco as fixed joint)
  int tip_num = j_.num.per_finger + j_.dim.fixed_first_segment + (not j_.dim.fixed_hook_segment);
  j_.segmentMatrices.idx_size = tip_num;

  // reset vectors back to empty
  j_.segmentMatrices.apply_flags.clear(); // wipe all flags
  j_.segmentMatrices.apply_flags.resize(tip_num, 0); // set all to 0 (false)
  j_.segmentMatrices.force.clear();
  j_.segmentMatrices.force.resize(tip_num, 0.0);

  std::string f1_names = "finger_1_segment_link_{X}";
  std::string f2_names = "finger_2_segment_link_{X}";
  std::string f3_names = "finger_3_segment_link_{X}";
  std::string f1_hook = "finger_1_finger_hook_link";
  std::string f2_hook = "finger_2_finger_hook_link";
  std::string f3_hook = "finger_3_finger_hook_link";

  // get the segment joints
  for (int i = 0; i < model->nbody; i++) {

    std::string name = mj_id2name(model, mjOBJ_BODY, i);

    // we assume the order must be correct without checking
    if (strcmp_w_sub(name, f1_names, tip_num)) {
      j_.segmentMatrices.f1_idx.push_back(i);
    }
    if (strcmp_w_sub(name, f2_names, tip_num)) {
      j_.segmentMatrices.f2_idx.push_back(i);
    }
    if (strcmp_w_sub(name, f3_names, tip_num)) {
      j_.segmentMatrices.f3_idx.push_back(i);
    }

    // if the finger hook is active (these will be added last)
    if (f1_hook == name) j_.segmentMatrices.f1_idx.push_back(i);
    if (f2_hook == name) j_.segmentMatrices.f2_idx.push_back(i);
    if (f3_hook == name) j_.segmentMatrices.f3_idx.push_back(i);
  }

  if (debug_) {
    print_vec(j_.segmentMatrices.f1_idx, "finger 1 segment idx");
    print_vec(j_.segmentMatrices.f2_idx, "finger 2 segment idx");
    print_vec(j_.segmentMatrices.f3_idx, "finger 3 segment idx");
  }
  
  if (j_.segmentMatrices.f1_idx.size() != tip_num) {
    throw std::runtime_error("f1_idx vec in get_segment_matrices() has size != num segments");
  }
  if (j_.segmentMatrices.f2_idx.size() != tip_num) {
    throw std::runtime_error("f2_idx vec in get_segment_matrices() has size != num segments");
  }
  if (j_.segmentMatrices.f3_idx.size() != tip_num) {
    throw std::runtime_error("f3_idx vec in get_segment_matrices() has size != num segments");
  }

  // std::cout << "get_segment_matrices() tip idx are " << j_.segmentMatrices.f1_idx[tip_num - 1]
  //   << ", " << j_.segmentMatrices.f2_idx[tip_num - 1]
  //   << ", " << j_.segmentMatrices.f3_idx[tip_num - 1] << '\n';

  // find the starting body orientation
  for (int j = 0; j < 9; j++) {

    // std::cout << "matrix values finger 2: " << data->xmat[j_.segmentMatrices.f2_idx[tip_num - 1] * 9 + j] << '\n';

    // use frame orientation of first joint for orientation of entire finger
    j_.segmentMatrices.finger1[j] = data->xmat[j_.segmentMatrices.f1_idx[0] * 9 + j];
    j_.segmentMatrices.finger2[j] = data->xmat[j_.segmentMatrices.f2_idx[0] * 9 + j];
    j_.segmentMatrices.finger3[j] = data->xmat[j_.segmentMatrices.f3_idx[0] * 9 + j];
  }
}

void set_segment_force(int seg_num, bool set_as, double force)
{
  /* toggle whether to apply force to a given segment */

  if (seg_num < 0 or seg_num >= j_.segmentMatrices.idx_size) {
    std::cout << "ERROR: seg_num is " << seg_num << '\n';
    throw std::runtime_error("apply_segment_force() recieved seg_num out of bounds");
  }

  // std::cout << "set segement force, seg_num = " << seg_num << ", force = " << force << "\n";

  j_.segmentMatrices.apply_flags[seg_num] = set_as;
  j_.segmentMatrices.force[seg_num] = force;
}

void resolve_segment_forces(mjModel* model, mjData* data)
{
  /* apply forces to segments specified, should be called every step */

  // std::cout << "resolve_segment_forces():\n";
  // print_vec(j_.segmentMatrices.apply_flags, "apply flags");
  // print_vec(j_.segmentMatrices.force, "force");
  // std::cout << "\n\n";

  for (int i = 0; i < j_.segmentMatrices.apply_flags.size(); i++) {
    if (j_.segmentMatrices.apply_flags[i]) {
      apply_segment_force(model, data, i, j_.segmentMatrices.force[i]);
      // std::cout << "applying force " << j_.segmentMatrices.force[i] << " on segment " << i << '\n';
    }
  }
}

void apply_segment_force(mjModel* model, mjData* data, int seg_num, double force)
{
  /* apply a force to a given segment from 1..N */

  if (seg_num < 0 or seg_num >= j_.segmentMatrices.idx_size) {
    std::cout << "ERROR: seg_num is " << seg_num << '\n';
    throw std::runtime_error("apply_segment_force() recieved seg_num out of bounds");
  }

  // lock the fingers in place
  for (int i : j_.con_idx.prismatic) {
    set_constraint(model, data, i, true);
  }
  for (int i : j_.con_idx.revolute) {
    set_constraint(model, data, i, true);
  }

  std::vector<std::vector<int>*> idx_vecs {
    &j_.segmentMatrices.f1_idx,
    &j_.segmentMatrices.f2_idx,
    &j_.segmentMatrices.f3_idx
  };

  std::vector<mjtNum*> mats {
    j_.segmentMatrices.finger1,
    j_.segmentMatrices.finger2,
    j_.segmentMatrices.finger3
  };

  // loop through and apply force to the given segment
  for (int i = 0; i < 3; i++) {

    // prepare to apply force outwards on fingertips
    mjtNum fvec[3] = { 0, 0, -force };
    mjtNum rotfvec[3];

    // std::cout << "finger " << i + 1 << " matrix values in apply: ";
    // for (int j = 0; j < 9; j++) std::cout << mats[i][j] << ", ";
    // std::cout << "\n";

    // rotate into the tip frame to pull directly horizontal
    mju_mulMatVec(rotfvec, mats[i], fvec, 3, 3);

    // apply force in cartesian space (joint space is qfrc_applied)
    data->xfrc_applied[(*idx_vecs[i])[seg_num] * 6 + 0] = rotfvec[0];
    data->xfrc_applied[(*idx_vecs[i])[seg_num] * 6 + 1] = rotfvec[1];
    data->xfrc_applied[(*idx_vecs[i])[seg_num] * 6 + 2] = rotfvec[2];

    // std::cout << "apply_segment_force() finger " << i + 1 << " rotfvec is " << rotfvec[0] << ", " << rotfvec[1]
    //   << ", " << rotfvec[2] << '\n';
  }
}

void apply_UDL(double total_force)
{
  /* apply a uniformally distributed load with a total force such that the force
  per segment will be applied as total_force / N */

  // do we apply force to joint 0 (which will have no effect)
  bool ignore_first_seg = false; // yes we do, otherwise the UDL is not uniform
  float force_per = total_force / (float) (j_.segmentMatrices.idx_size - ignore_first_seg);

  // add force also to first segment for visual consistency in mujoco, it has no effect
  for (int i = 0; i < j_.segmentMatrices.idx_size; i++) {
    set_segment_force(i, true, force_per);
  }
}

void wipe_segment_forces()
{
  /* remove all segment fores */

  for (int i = 0; i < j_.segmentMatrices.idx_size; i++) {
    set_segment_force(i, false, 0.0);
  }
}

void apply_tip_force(double force)
{
  /* apply a force at the tip of the finger */

  set_segment_force(j_.segmentMatrices.idx_size - 1, true, force);
}

void apply_tip_force(mjModel* model, mjData* data, double force, bool reset)
{
  /* apply a horizontal force to the tip of the finger */

  /* OLD CODE: THIS FUNCTION SHOULD NO LONGER BE CALLED, it has been replaced
  by the apply_tip_force(double_force) version */

  std::runtime_error("apply_tip_force(model, data, force, reset) is depreciated and should not be called");
  
  static bool first_call = true;
  static std::vector<int> tip_idx;
  static mjtNum tip_mat1[9];
  static mjtNum tip_mat2[9];
  static mjtNum tip_mat3[9];
  static std::vector<mjtNum*> tip_mat{ tip_mat1, tip_mat2, tip_mat3 };

  // the first time this function is called, find the tip body indexes
  if (first_call or reset) {

    if (reset) tip_idx.clear();

    // get the name of the last finger link (hook link is removed by mujoco as fixed joint)

    /* this method does not work if the hook link is in use, as it is the final joint not
    one of the segment joints. Hence this function is depreciated and should not be called */

    int tip_num = j_.num.per_finger + j_.dim.fixed_first_segment;
    std::string tip_name = "finger_{X}_segment_link_" + std::to_string(tip_num);

    for (int i = 0; i < model->nbody; i++) {
      std::string name = mj_id2name(model, mjOBJ_BODY, i);
      if (strcmp_w_sub(name, tip_name, 3)) {
        tip_idx.push_back(i);
      }
    }

    if (debug_) {
      print_vec(tip_idx, "finger body tip_idx");
    }
    
    if (tip_idx.size() != 3) {
      throw std::runtime_error("tip_idx vector in apply_tip_force(...) has size != 3");
    }

    // find the starting body orientation
    for (int i = 0; i < 3; i++) {
      for (int j = 0; j < 9; j++) {
        tip_mat[i][j] = data->xmat[tip_idx[i] * 9 + j];
      }
    }

    first_call = false;
  }

  // for lock the fingers in place
  for (int i : j_.con_idx.prismatic) {
    set_constraint(model, data, i, true);
  }
  for (int i : j_.con_idx.revolute) {
    set_constraint(model, data, i, true);
  }

  // loop through and apply force to fingertips
  for (int i = 0; i < 3; i++) {

    // prepare to apply force outwards on fingertips
    mjtNum fvec[3] = { 0, 0, -force };
    mjtNum rotfvec[3];

    // rotate into the tip frame to pull directly horizontal
    mju_mulMatVec(rotfvec, tip_mat[i], fvec, 3, 3);

    // apply force in cartesian space (joint space is qfrc_applied)
    data->xfrc_applied[tip_idx[i] * 6 + 0] = rotfvec[0];
    data->xfrc_applied[tip_idx[i] * 6 + 1] = rotfvec[1];
    data->xfrc_applied[tip_idx[i] * 6 + 2] = rotfvec[2];
  }
}

/* ----- simulation ----- */

void before_step(mjModel* model, mjData* data)
{
  /* before making a simulation step */

  mju_zero(data->ctrl, model->nu);
  mju_zero(data->qfrc_applied, model->nv);
  mju_zero(data->xfrc_applied, 6 * model->nbody);
}

void step(mjModel* model, mjData* data)
{
  /* make a simulation step */

  // mj_step(model, data);

  mj_step1(model, data);

  /* 
  To make the 'leadscrews' non-backdriveable, we want no forces to be
  transferred from the finger to the finger platform/joints. So we will
  try wiping any forces, and trust that the momentum forces are sufficiently
  small.

  The joints to wipe are either:
    finger_1_revolute_joint (1 + panda)
    finger_2_revolute_joint (12 + panda)
    finger_3_revolute_joint (23 + panda)
  or:
    finger_1_segment_joint_1 (2 + panda)
    finger_2_segment_joint_2 (13 + panda)
    finger_3_segment_joint_3 (24 + panda)

  */   

  static std::vector<int> to_wipe {
    j_.idx.gripper[j_.gripper.prismatic[0]],  // 0
    j_.idx.gripper[j_.gripper.prismatic[1]],  // 11
    j_.idx.gripper[j_.gripper.prismatic[2]],  // 22
    j_.idx.gripper[j_.gripper.revolute[0]],   // 1
    j_.idx.gripper[j_.gripper.revolute[1]],   // 12
    j_.idx.gripper[j_.gripper.revolute[2]],   // 23
  };

  control(model, data);   // since ctrl pntr not assigned

  for (int i = 0; i < to_wipe.size(); i++) {
    // all are (nv * 1), and nv = 34 for gripper, which = njnts
    // data->qfrc_passive[to_wipe[i]] = 0;  // passive force
    // data->efc_vel[to_wipe[i]] = 0;       // velocity in constraint space: J*qvel
    // data->efc_aref[to_wipe[i]] = 0;      // reference pseudo-acceleartion
    // data->qfrc_bias[to_wipe[i]] = 0;     // C(qpos, qvel)
    // data->cvel[to_wipe[i]] = 0;          // com-based velcotiy [3D rot; 3D tran]

    // data->qfrc_unc[to_wipe[i]] = 0;
    // data->qacc_unc[to_wipe[i]] = 0;
  }

  // // for testing, applly known force to the end of the finger
  // data->xfrc_applied[11 * 6 + 1] = 10;

  mj_step2(model, data);
  return;

  mj_fwdActuation(model, data);
  mj_fwdAcceleration(model, data);
  mj_fwdConstraint(model, data);


  std::vector<mjtNum> qfrc;
  // std::cout << "qfrc constraint is ";
  for (int i = 0; i < to_wipe.size(); i++) {

    // // wipe forces arising from constraints (contacts)
    // qfrc.push_back(data->qfrc_constraint[to_wipe[i]]);
    // data->qfrc_constraint[to_wipe[i]] = 0;
    // // std::cout << data->qfrc_constraint[to_wipe[i]] << " ";
  } 
  // std::cout << "\n";

  // int j = 0;
  // for (int i : j_.gripper.prismatic) {
  //   data->ctrl[j_.num.panda + i] += -qfrc[j];
  //   j += 1;
  // }
  // for (int i : j_.gripper.revolute) {
  //   data->ctrl[j_.num.panda + i] += -qfrc[j];
  //   j += 1;
  // }
  // mj_fwdActuation(model, data);
  // mj_fwdAcceleration(model, data);
  // mj_fwdConstraint(model, data);

  mj_sensorAcc(model, data);
  mj_checkAcc(model, data);

  // compare forward and inverse solutions if enabled
  // if( mjENABLED(mjENBL_FWDINV) )
  if (model->opt.enableflags and mjENBL_FWDINV)
      mj_compareFwdInv(model, data);

  mj_Euler(model, data);


}

void after_step(mjModel* model, mjData* data)
{
  /* after making a simulation step */

  // compute the contact forces on all bodies
  mj_rnePostConstraint(model, data);

  update_all(model, data);
}

/* ----- control ----- */

void control(const mjModel* model, mjData* data)
{
  /* Control function for mujoco */

  // disable this warning as added objects contribute nv but not nu
  if (false and model->nu != model->nv) {
    printf("Warning from Luke's control function: "
      "model nu (num ctrl inputs) does not equal nv (num DoF). "
      "nu = %i, nv = %i\n", model->nu, model->nv);
    throw std::runtime_error("nu != nv for your model");
  }

  if (j_.in_use.panda) {
    control_panda(model, data);
  }

  if (j_.in_use.gripper) {
    control_gripper(model, data, target_.next);
  }

  if (j_.in_use.base) {
    control_base(model, data);
  }
}

void control_panda(const mjModel* model, mjData* data)
{
  /* control the panda joints */

  // mju_scl(data->ctrl, data->qvel, -0.1 * 100, model->nv);

}

void control_gripper(const mjModel* model, mjData* data, Gripper& target)
{
  /* control the gripper joints */

  double u = 0;

  double force_lim = 100;

  int n = j_.num.panda + j_.num.base;

  // input the control signals
  for (int i : j_.gripper.prismatic) {
    u = ((*j_.to_qpos.gripper[i]) - target.x) * j_.ctrl.kp.x 
      + (*j_.to_qvel.gripper[i]) * j_.ctrl.kd.x;
    // if (abs(u) > force_lim) {
    //   std::cout << "x frc limited from " << u << " to ";
    //   u = force_lim * sign(u);
    //   std::cout << u << '\n';
    // }
    data->ctrl[n + i] = -u;
  }

  for (int i : j_.gripper.revolute) {
    u = ((*j_.to_qpos.gripper[i]) - target.th) * j_.ctrl.kp.y 
      + (*j_.to_qvel.gripper[i]) * j_.ctrl.kd.y;
    // if (abs(u) > force_lim) {
    //   std::cout << "y frc limited from " << u << " to ";
    //   u = force_lim * sign(u);
    //   std::cout << u << '\n';
    // }
    data->ctrl[n + i] = -u;
  }
  
  for (int i : j_.gripper.palm) {
    u = ((*j_.to_qpos.gripper[i]) - target.z) * j_.ctrl.kp.z 
      + (*j_.to_qvel.gripper[i]) * j_.ctrl.kd.z;
    // if (abs(u) > force_lim) {
    //   std::cout << "z frc limited from " << u << " to ";
    //   u = force_lim * sign(u);
    //   std::cout << u << '\n';
    // }
    data->ctrl[n + i] = -u;
  }
}

void control_base(const mjModel* model, mjData* data)
{
  /* control the base joint */

  double u = 0;
  int n = j_.num.panda;

  if (j_.num.base != 1) {
    throw std::runtime_error("base dof does not equal 1");
  }

  for (int i = 0; i < j_.num.base; i++) {
    u = ((*j_.to_qpos.base[i]) - target_.base[i]) * j_.ctrl.base_kp
      + (*j_.to_qvel.base[i]) * j_.ctrl.base_kd;
    data->ctrl[n + i] = -u;
  }
}

void update_state(const mjModel* model, mjData* data)
{
  /* update our record of the model state */

  /* this function has been replaced by accessing qpos and qvel directly via
  their pointers. It can still be used for helpful printing and debugging
  but should never be called in the main loop */

  if (j_.in_use.panda) {
    for (int i = 0; i < j_.num.panda; i++) {
      j_.qpos.panda[i] = data->qpos[j_.qposadr.panda[i]];
      j_.qvel.panda[i] = data->qvel[j_.qveladr.panda[i]];
    }
  }

  if (j_.in_use.gripper) {
    for (int i = 0; i < j_.num.gripper; i++) {
      j_.qpos.gripper[i] = data->qpos[j_.qposadr.gripper[i]];
      j_.qvel.gripper[i] = data->qvel[j_.qveladr.gripper[i]];
    }
  }

  if (j_.in_use.finger) {
    for (int i = 0; i < j_.num.finger; i++) {
      j_.qpos.finger[i] = data->qpos[j_.qposadr.finger[i]];
      j_.qvel.finger[i] = data->qvel[j_.qveladr.finger[i]];
    }
  }

  if (j_.in_use.base) {
    for (int i = 0; i < j_.num.base; i++) {
      j_.qpos.base[i] = data->qpos[j_.qposadr.base[i]];
      j_.qvel.base[i] = data->qvel[j_.qveladr.base[i]];
    }
  }

  // // report state for testing
  // j_.print_qpos();
  // j_.print_qvel();

}

void print_state(const mjModel* model, mjData* data)
{
  /* print the qpos of all the joints */

  update_state(model, data);
  j_.print_qpos();
  j_.print_qvel();
}

void update_all(mjModel* model, mjData* data)
{
  /* update the state of everything in the simulation */

  // update_state(model, data); // NO LONGER NEEDED
  // update_objects(model, data); // NO LONGER NEEDED

  if (j_.ctrl.stepper) {
    update_stepper(model, data);
  }
  else {
    throw std::runtime_error("non-stepper not implemented");
  }

  // // for testing
  // update_state(model, data);
  // j_.print_qpos();
  // target_.end.print();
}

void update_stepper(mjModel* model, mjData* data)
{
  /* update the gripper joint positions and determine equilibirum/target_reached 
  assuming a stepper motor style */

  constexpr static bool log_test_data = true;

  bool stepped = false;

  if (data->time > last_step_time_ + j_.ctrl.time_per_step) {

    // we can optionally log position data to see motor response to steps
    if (log_test_data) {
      Gripper temp;
      temp.set_xyz_m_rad(*j_.to_qpos.gripper[0], *j_.to_qpos.gripper[1], *j_.to_qpos.gripper[6]);
      target_.timedata.add(data->time);
      target_.target_stepperx.add(target_.next.x * 1e6);
      target_.target_steppery.add(target_.next.y * 1e6);
      target_.target_stepperz.add(target_.next.z * 1e6);
      target_.target_basez.add(target_.base[0] * 1e6);
      target_.actual_stepperx.add(temp.x * 1e6);
      target_.actual_steppery.add(temp.y * 1e6);
      target_.actual_stepperz.add(temp.z * 1e6);
      target_.actual_basez.add(*j_.to_qpos.base[0] * 1e6);
    }

    // check if motors are moving, if not, lock them
    update_constraints(model, data);

    // apply a step to any motors still not at the target
    last_step_time_ = data->time;
    target_.next.step_to(target_.end, j_.ctrl.num_steps);
    stepped = true;

    // uncomment these to see ratio of steps to waits
    // std::cout << "step!\n";
  }
  else {
    // std::cout << "wait-";
  }
}

void update_objects(const mjModel* model, mjData* data)
{
  /* update the position of the objects in the simulation */

  for (int i = 0; i < oh_.names.size(); i++) {
    if (oh_.in_use[i]) {
      oh_.qpos[i].update(model, data, oh_.qposadr[i]);
    }
  }

  // // for testing
  // QPos test = get_object_qpos();
  // printf("qpos is xyz (%.3f, %.3f, %.3f)\n", test.x, test.y, test.z);

  // get_object_contact_forces(model, data);
}

void update_constraints(mjModel* model, mjData* data)
{
  /* control toggling of constraints which log motor positions once they finish
  moving */

  static bool old_x = true;
  static bool old_y = true;
  static bool old_z = true;

  bool new_x = target_.x_moving();
  bool new_y = target_.y_moving();
  bool new_z = target_.z_moving();

  // // FOR TESTING - this work was not finished
  // for (int i : j_.con_idx.prismatic) {
  //   target_constraint(model, data, i, not new_x, 0);
  // }
  // for (int i : j_.con_idx.revolute) {
  //   target_constraint(model, data, i, not new_y, 1);
  // }
  // for (int i : j_.con_idx.palm) {
  //   target_constraint(model, data, i, not new_z, 2);
  // }

  // return;

  if (new_x != old_x) {
    if (new_x) {
      // constraint enable is true
      for (int i : j_.con_idx.prismatic) {
        set_constraint(model, data, i, false);
      }
    }
    else {
      // constraint enable is false
      for (int i : j_.con_idx.prismatic) {
        set_constraint(model, data, i, true);
      }
    }
    old_x = new_x;
  }
  
  if (new_y != old_y) {
    if (new_y) {
      // constraint enable is true
      for (int i : j_.con_idx.revolute) {
        set_constraint(model, data, i, false);
      }
    }
    else {
      // constraint enable is false
      for (int i : j_.con_idx.revolute) {
        set_constraint(model, data, i, true);
      }
    }
    old_y = new_y;
  }

  if (new_z != old_z) {
    if (new_z) {
      // constraint enable is true
      for (int i : j_.con_idx.palm) {
        set_constraint(model, data, i, false);
      }
    }
    else {
      // constraint enable is false
      for (int i : j_.con_idx.palm) {
        set_constraint(model, data, i, true);
      }
    }
    old_z = new_z;
  }

  // // for testing
  // std::cout << "Prismatic constraints: ";
  // for (int i : j_.con_idx.prismatic) {
  //   std::cout << (int) model->eq_active[i] << ", ";
  // }
  // std::cout << "\n";
}

/* ----- set gripper target ----- */

bool set_gripper_target_step(int x, int y, int z)
{
  /* set a step target for the gripper motors */

  target_.last_robot = Target::Robot::gripper;

  // return false if target is outside motor limits
  return target_.end.set_xyz_step(x, y, z);
}

bool set_gripper_target_m(double x, double y, double z)
{
  /* set a motor state target for the gripper, returns true when reached */

  target_.last_robot = Target::Robot::gripper;

  // return false if the target is outside motor limits
  return target_.end.set_xyz_m(x, y, z);
}

bool set_gripper_target_m_rad(double x, double th, double z)
{
  /* sets a joint state target for the gripper, returns true when reached */

  target_.last_robot = Target::Robot::gripper;

  // return false if the target is outside motor limits
  return target_.end.set_xyz_m(x, th, z);
}

bool move_gripper_target_step(int x, int y, int z)
{
  /* adjust the gripper target by the indicated number of steps */

  target_.last_robot = Target::Robot::gripper;

  // return false if the target is outside motor limits
  return target_.end.set_xyz_step(target_.end.step.x + x, target_.end.step.y + y, 
    target_.end.step.z + z);
}

bool move_gripper_target_m(double x, double y, double z)
{
  /* adjust gripper target by the indicated distances in metres */

  target_.last_robot = Target::Robot::gripper;

  // return false if the target is outside motor limits
  return target_.end.set_xyz_m(target_.end.x + x, target_.end.y + y,
    target_.end.z + z);
}

bool move_gripper_target_m_rad(double x, double th, double z)
{
  /* adjust the gripper joint values */

  target_.last_robot = Target::Robot::gripper;

  // return false if the target is outside motor limits
  return target_.end.set_xyz_m_rad(target_.end.x + x, target_.end.th + th, 
    target_.end.z + z);
}

bool move_base_target_m(double x, double y, double z)
{
  /* move the base target in x, y, z */

  target_.last_robot = Target::Robot::panda;

  /* only z motion currently implemented */
  target_.base[0] += z;

  // check limits, currently only z movements supported
  double z_min = luke::Target::base_z_min;
  double z_max = luke::Target::base_z_max;

  // check if we have gone outside the limits
  if (target_.base[0] > z_max) {
    target_.base[0] = z_max;
    return false;
  }
  if (target_.base[0] < z_min) {
    target_.base[0] = z_min;
    return false;
  }

  return true;
}

void print_target()
{
  std::cout << "The target gripper state is:";
  target_.end.print();
}

void update_target()
{
  target_.end.update();
}

/* ----- sensing ------ */

gfloat read_armadillo_gauge(const mjData* data, int finger)
{
  /* read the virtual strain gauge for one finger */

  arma::vec joint_values(j_.num.per_finger, arma::fill::zeros);

  // get the joint values for this finger
  for (int i = 0; i < j_.num.per_finger; i++) {
    joint_values(i) = 
      data->qpos[j_.idx.finger[i + finger * j_.num.per_finger]];
  }

  // next convert this into X and Y coordinates
  arma::vec cumulative(j_.num.per_finger, arma::fill::zeros);
  arma::mat finger_xy(j_.num.per_finger + 1, 2, arma::fill::zeros);

  // if first segment is locked
  if (j_.dim.fixed_first_segment)
    finger_xy(0, 0) = j_.dim.segment_length;
  else
    finger_xy(0, 0) = 0;

  for (int i = 0; i < j_.num.per_finger; i++) {

    // keep cumulative total of angular sum
    if (i == 0) {
      cumulative(i) = joint_values(i);
    }
    else {
      cumulative(i) = cumulative(i - 1) + joint_values(i);
    }

    // calculate cartesian coordinates of each joint
    finger_xy(i + 1, 0) = finger_xy(i, 0)
      + j_.dim.segment_length * std::cos(cumulative(i));
    finger_xy(i + 1, 1) = finger_xy(i, 1) 
      + j_.dim.segment_length * std::sin(cumulative(i));
  }

  // polyfit a cubic curve to these joint positions
  arma::vec coeff = arma::polyfit(finger_xy.col(0), finger_xy.col(1), j_.gauge.order);

  // evaluate y at the gauge x position
  gfloat y = 0.0;
  for (int i = 0; i <= j_.gauge.order; i++) {
    y += coeff(i) * std::pow(j_.gauge.xpos, j_.gauge.order - i);
  }

  /* The equation relating the force P to deflection delta is:
        delta = (P * l^3) / (3 * E * I)
     We can approximate the P / 3EI as proportional to our strain, k:
        delta = k * l^3
            k = delta / l^3
     Hence we our approximated strain, k, as our gauge reading
  */

  // // calculate the approximated gauge reading
  // gfloat k = y / j_.gauge.xpos_cubed;

  // // transfer to SI units for force (optional)
  // // THIS IS NOT ACCURATE as L^3 only applies at tip of beam
  // // BETTER TO NOT PROCESS TO SI as it removes this functions dependence on j_.dim.EI
  // gfloat P = k * (3 * j_.dim.EI);

  /* the SI result is not accurate because the finger stiffness is not
  accurate (here we do not have the right E). However, tuning the stiffness
  to be perfect is not helpful as the simulation can become unstable and the
  interaction with the simulated 'motors' is already not realistic */

  /* Finally, we want to scale this data. To get an idea of the size of k, lets
     take some default values:
      xpos = 50mm
      y_max == xpos -> this is from the finger bending to 45deg
     Hence, an absolute maximum value would be:
      k = xpos / cbrt(xpos)
      k = 0.136
     Lets scale this to the range -100, +100

     Lets scale the data to the range -1, +1. First, what is the maximum
     expected force?

     k = P / 3EI
     E = 200e9 Pa
     I = 1/12 * hb^3 where h = 28mm and b = 0.9mm
     I = 1.71e-12 m^4

     hence, with maximum expected force of 20N, we get:

     k = 20 / (3 * 200 * 1.71) * (10e-12 * 10e-9)
     k = 19.6 m^-2
  */

  // k *= (100.0 / 0.136);

  // return y value in millimeters, unprocessed (OLD: return P;)
  return y * 1000;
}

gfloat verify_armadillo_gauge(const mjData* data, int finger,
  std::vector<float>& vec_joint_x, std::vector<float>& vec_joint_y,
  std::vector<float>& vec_coefficients, std::vector<float>& vec_errors)
{
  /* read the virtual strain gauge for one finger */

  arma::vec joint_values(j_.num.per_finger, arma::fill::zeros);

  // get the joint values for this finger
  for (int i = 0; i < j_.num.per_finger; i++) {
    // joint_values(i) = 
    //   data->qpos[j_.idx.finger[i + finger * j_.num.per_finger]];

    joint_values(i) = *j_.to_qpos.finger[i + finger * j_.num.per_finger];
  }

  // next convert this into X and Y coordinates
  arma::vec cumulative(j_.num.per_finger, arma::fill::zeros);
  arma::mat finger_xy(j_.num.per_finger + 1, 2, arma::fill::zeros);

  // if first segment is locked
  if (j_.dim.fixed_first_segment)
    finger_xy(0, 0) = j_.dim.segment_length;
  else
    finger_xy(0, 0) = 0;

  for (int i = 0; i < j_.num.per_finger; i++) {

    // keep cumulative total of angular sum
    if (i == 0) {
      cumulative(i) = joint_values(i);
    }
    else {
      cumulative(i) = cumulative(i - 1) + joint_values(i);
    }

    // calculate cartesian coordinates of each joint
    finger_xy(i + 1, 0) = finger_xy(i, 0)
      + j_.dim.segment_length * std::cos(cumulative(i));
    finger_xy(i + 1, 1) = finger_xy(i, 1) 
      + j_.dim.segment_length * std::sin(cumulative(i));
  }

  // polyfit a cubic curve to these joint positions
  arma::vec coeff = arma::polyfit(finger_xy.col(0), finger_xy.col(1), j_.gauge.order);

  // evaluate y at the gauge x position
  gfloat y = 0.0;
  for (int i = 0; i <= j_.gauge.order; i++) {
    y += coeff(i) * std::pow(j_.gauge.xpos, j_.gauge.order - i);
  }

  /* The equation relating the force P to deflection delta is:
        delta = (P * l^3) / (3 * E * I)
     We can approximate the P / 3EI as proportional to our strain, k:
        delta = k * l^3
            k = delta / l^3
     Hence we our approximated strain, k, as our gauge reading
  */

  // // calculate the approximated gauge reading
  // gfloat k = y / j_.gauge.xpos_cubed;

  // // transfer to SI units for force (optional)
  // gfloat P = k * (3 * j_.dim.EI);

  /* the SI result is not accurate because the finger stiffness is not
  accurate (here we do not have the right E). However, tuning the stiffness
  to be perfect is not helpful as the simulation can become unstable and the
  interaction with the simulated 'motors' is already not realistic */

  /* Finally, we want to scale this data. To get an idea of the size of k, lets
     take some default values:
      xpos = 50mm
      y_max == xpos -> this is from the finger bending to 45deg
     Hence, an absolute maximum value would be:
      k = xpos / cbrt(xpos)
      k = 0.136
     Lets scale this to the range -100, +100

     Lets scale the data to the range -1, +1. First, what is the maximum
     expected force?

     k = P / 3EI
     E = 200e9 Pa
     I = 1/12 * hb^3 where h = 28mm and b = 0.9mm
     I = 1.71e-12 m^4

     hence, with maximum expected force of 20N, we get:

     k = 20 / (3 * 200 * 1.71) * (10e-12 * 10e-9)
     k = 19.6 m^-2
  */

  // k *= (100.0 / 0.136);

  /* ----- only difference between read/verfiy is as follows ----- */

  int num_points = j_.num.per_finger + 1;
  int num_coeff = j_.gauge.order + 1;

  vec_joint_x.resize(num_points);
  vec_joint_y.resize(num_points);
  vec_errors.resize(num_points);
  vec_coefficients.resize(num_coeff);

  // save the joint angles
  for (int i = 0; i < num_points; i++) {
    vec_joint_x[i] = finger_xy(i, 0);
    vec_joint_y[i] = finger_xy(i, 1);
  }

  // save the cubic coefficients
  for (int i = 0; i < num_coeff; i++) {
    vec_coefficients[i] = coeff(i);
  }

  // evaluate the predicted y position and resulting error
  float cum_error = 0;
  for (int i = 0; i < num_points; i++) {
    float y = 0.0;
    for (int j = 0; j < num_coeff; j++) {
      y += vec_coefficients[j] * std::pow(vec_joint_x[i], j_.gauge.order - j);
    }
    float error = vec_joint_y[i] - y;
    vec_errors[i] = error;
    cum_error += abs(error);
  }

  return cum_error / num_points;

  /* ----- end read/verify differences ----- */
}

gfloat verify_small_angle_model(const mjData* data, int finger,
  std::vector<float>& joint_angles, std::vector<float>& joint_pred,
  std::vector<float>& pred_x, std::vector<float>& pred_y, std::vector<float>& theory_y,
  std::vector<float>& theory_x_curve, std::vector<float>& theory_y_curve,
  float force, float finger_stiffness, int force_style)
{
  /* evaluate the difference in joint angle between the actual and model
  predicted values
  
  force style: 0 = point load
               1 = UDL
  */

  int ffs =  j_.dim.fixed_first_segment;

  int N = j_.num.per_finger;
  joint_angles.resize(N);
  joint_pred.resize(N);
  pred_x.resize(N + 1);
  pred_y.resize(N + 1);
  theory_y.resize(N + 1 + ffs);
  std::vector<float> theory_x(N + 1 + ffs);

  int theory_N = 50;
  float theory_step = j_.dim.finger_length / (float) theory_N;
  theory_x_curve.resize(theory_N);
  theory_y_curve.resize(theory_N);

  std::vector<float> joint_errors(N);

  float cum_error = 0;
  float cum_pred_angle = 0;

  if (j_.dim.fixed_first_segment) {
    pred_x[0] = j_.dim.segment_length;
    theory_x[1] = j_.dim.segment_length;
    theory_y[1] = (force * std::pow(theory_x[1], 3)) / (3 * j_.dim.EI); // WRONG EQUATION!
  }
  else {
    pred_x[0] = 0; 
  }

  pred_y[0] = 0;
  theory_x[0] = 0;
  theory_y[0] = 0;
  theory_x_curve[0] = 0;
  theory_y_curve[0] = 0;

  // get the joint values for this finger
  for (int i = 0; i < N; i++) {

    // determine the joint stiffness of this joint
    int n = i + 1;
    float c = j_.dim.joint_stiffness[i];

    // actual joint values
    joint_angles[i] = *j_.to_qpos.finger[i + finger * N];

    // predicted joint values
    joint_pred[i] = ((N - n + 1) * force * j_.dim.finger_length) / (N * c);

    // joint angle error
    joint_errors[i] = joint_angles[i] - joint_pred[i];
    cum_error += abs(joint_errors[i]);

    // predicted xy positions
    cum_pred_angle += joint_pred[i];
    pred_x[i + 1] = pred_x[i] + j_.dim.segment_length * std::cos(cum_pred_angle);
    pred_y[i + 1] = pred_y[i] + j_.dim.segment_length * std::sin(cum_pred_angle);

    // // theory y position
    // theory_x[i + 1 + ffs] = theory_x[i + ffs] + j_.dim.segment_length;
    // theory_y[i + 1 + ffs] = (force * std::pow(theory_x[i + 1 + ffs], 3)) / (3 * j_.dim.EI); 

    // basic theory attempt 2
    if (force_style == 0) {
      double theory_factor = (force) / (6.0 * j_.dim.EI);
      double x = (i + 1) * j_.dim.segment_length;
      theory_x[i + 1 + ffs] = x;
      theory_y[i + 1 + ffs] = theory_factor * (-std::pow(x, 3) + 3 * j_.dim.finger_length * std::pow(x, 2)); 
    }
    else if (force_style == 1) {
      double theory_factor = ((force / j_.dim.finger_length) / (24.0 * j_.dim.EI));
      double x = (i + 1) * j_.dim.segment_length;
      theory_x[i + 1 + ffs] = x;
      theory_y[i + 1 + ffs] = theory_factor * 
        (std::pow(x, 4) - 4 * j_.dim.finger_length * std::pow(x, 3) 
          + 6 * j_.dim.finger_length * j_.dim.finger_length * std::pow(x, 2)); 
    }
    else {
      std::cout << "force_style = " << force_style << '\n';
      throw std::runtime_error("force style was not 0 or 1 in verify_small_angle_model(...)");
    }
    
  }

  if (force_style == 0) {
    fill_theory_curve(theory_x_curve, theory_y_curve, force, theory_N);
  }
  else if (force_style == 1) {
    fill_UDL_theory_curve(theory_x_curve, theory_y_curve, force, theory_N);
  }
  
  // // approximate free end tangent angle
  // double B = (force * std::pow(j_.dim.finger_length, 2)) / (j_.dim.EI);
  // double phi_0 = 0.5 * B * (1.0 - (1.0/12.0) * std::pow(B, 2));
  // double gamma = M_PI_2;

  // // factors for basic theory
  // double f1 = -force / 6.0;
  // double f2 = (force * std::pow(j_.dim.finger_length, 2)) / 2.0;
  // double f3 = -(force * std::pow(j_.dim.finger_length, 3)) / 3.0;

  // // create theory curve
  // for (int i = 0; i < theory_N - 1; i++) {

  //   // // proportional to L cubed, basic
  //   // theory_x_curve[i + 1] = theory_x_curve[i] + theory_step;
  //   // theory_y_curve[i + 1] = (force * std::pow(theory_x_curve[i + 1], 3)) / (3 * j_.dim.EI); 

  //   // basic theory attempt 2
  //   // double x = j_.dim.finger_length * (1.0 - (i / (float) (theory_N - 2)));
  //   // theory_x_curve[i + 1] = theory_x_curve[i] + theory_step;
  //   // theory_y_curve[i + 1] = (-1.0 / j_.dim.EI) * ((f1 * std::pow(x, 3)) + (f2 * x) + f3); 

  //   double theory_factor = (force / (6.0 * j_.dim.EI));
  //   double x = j_.dim.finger_length * ((i / (float) (theory_N - 2)));
  //   theory_x_curve[i + 1] = x;
  //   theory_y_curve[i + 1] = theory_factor * (-std::pow(x, 3) + 3 * j_.dim.finger_length * std::pow(x, 2));  

  //   // following Bisshopp end angle approximation ... how to get cartesian?

  //   // // // Batista paper, analytical solution
  //   // #ifndef LUKE_PREVENT_BOOST
  //   //   double s = 1.0 - (i / (float) (theory_N - 2));
  //   //   double M0 = 0.0;
  //   //   double alpha = 1.8785;
  //   //   luke_boost::ArcPoint p = luke_boost::get_point(s, force, M0, j_.dim.finger_length,
  //   //     j_.dim.EI, alpha);
  //   //   theory_x_curve[i + 1] = p.x;
  //   //   theory_y_curve[i + 1] = p.y;
  //   // #endif
  // }

  // return average error
  return (gfloat) cum_error / N;
}

void fill_theory_curve(std::vector<float>& theory_X, std::vector<float>& theory_Y, 
  float force, int num)
{
  /* take two vectors (which are wiped) and fill them with the theory curve, this
  is basic bending theory for Euler-Bernoulli beam. Force should be given in NEWTONS.
  This does a point load on a cantilever */

  theory_X.clear();
  theory_Y.clear();

  theory_X.resize(num);
  theory_Y.resize(num);

  // create theory curve
  for (int i = 0; i < num; i++) {

    double theory_factor = (force / (6.0 * j_.dim.EI));
    double x = j_.dim.finger_length * ((i / (float) (num - 1)));
    theory_X[i] = x;
    theory_Y[i] = theory_factor * (-std::pow(x, 3) + 3 * j_.dim.finger_length * std::pow(x, 2)); 
  }
}

void fill_UDL_theory_curve(std::vector<float>& theory_X, std::vector<float>& theory_Y,
  float force, int num)
{
  /* take two vectors (which are wiped) and fill them with the theory curve, this
  is basic bending theory for Euler-Bernoulli beam. Force should be given in NEWTONS.
  This does a UDL on a cantilever */

  theory_X.clear();
  theory_Y.clear();

  theory_X.resize(num);
  theory_Y.resize(num);

  // convert force (total force) into force per metre
  float L = j_.dim.finger_length;
  float W = force / L;

  // create theory curve
  for (int i = 0; i < num; i++) {

    double theory_factor = (W / (24.0 * j_.dim.EI));
    double x = L * ((i / (float) (num - 1)));
    theory_X[i] = x;
    theory_Y[i] = theory_factor * (std::pow(x, 4) - 4 * L * std::pow(x, 3) + 6 * L * L * std::pow(x, 2)); 
  }
}

std::vector<float> discretise_curve(std::vector<float> X, std::vector<float> truth_X, 
  std::vector<float> truth_Y)
{
  /* takes a detailed curve (truth_X, truth_Y) and finds the more coarse points
  (X, Y), returning the vector Y when given X */

  int n_profile = X.size();
  int n_truth = truth_X.size();

  std::vector<float> Y(n_profile);

  int last = 0;
  bool found = false;

  for (int i = 0; i < n_profile; i++) {

    // find the closest X point in the 'truth'
    for (int j = last; j < n_truth; j++) {

      if (truth_X[j] > X[i]) {
        last = j - 1;
        found = true;
        break;
      }
    }

    float truth_X_val;
    float truth_Y_val;

    if (not found) {
      truth_X_val = truth_X[n_truth - 1];
      truth_Y_val = truth_Y[n_truth - 1];
    }
    else if (last < 0) {
      truth_X_val = truth_X[0];
      truth_Y_val = truth_Y[0];
    }
    else {
      // interpolate
      float interval = truth_X[last + 1] - truth_X[last];
      float a = (truth_X[last + 1] - X[i]) / interval;
      float b = 1 - a;
      truth_X_val = (a * truth_X[last] + b * truth_X[last + 1]);
      truth_Y_val = (a * truth_Y[last] + b * truth_Y[last + 1]);
    }

    // save this Y value
    Y[i] = truth_Y_val;

    // prepare to loop
    found = false;
  }

  return Y;
}

std::vector<gfloat> get_gauge_data(const mjModel* model, mjData* data)
{
  /* Get the position of the finger joints */

  if (not j_.in_use.finger) {
    printf("Error: gauge data has been request without using segments\n");
    return std::vector<gfloat>{0, 0, 0};
  }

  std::vector<gfloat> readings(3);

  // use armadillo to detect finger bending
  if (j_.gauge.use_armadillo_gauges) {
    for (int i = 0; i < 3; i++) {
      readings[i] = read_armadillo_gauge(data, i);
    }
  }
  // use fingertip forces
  else {
    Forces forces = get_object_forces(model, data);
    readings[0] = (gfloat) forces.all.finger1_local[1];
    readings[1] = (gfloat) forces.all.finger2_local[1];
    readings[2] = (gfloat) forces.all.finger3_local[1];
  }

  return readings;  
}

gfloat get_palm_force(const mjModel* model, mjData* data)
{
  /* get the axial force on the palm */

  return (gfloat) oh_.get_palm_force(model, data);
}

std::vector<gfloat> get_panda_state(const mjData* data)
{
  /* Get the state of the panda joints */

  if (not j_.in_use.panda) return std::vector<gfloat>{ 0 };

  std::vector<gfloat> joint_values(j_.num.panda);

  for (int i = 0; i < j_.num.panda; i++) {
    joint_values[i] = data->qpos[j_.idx.panda[i]];
  }

  return joint_values;
}

std::vector<gfloat> get_gripper_state(const mjData* data)
{
  /* Get the state of the gripper joints */

  if (not j_.in_use.gripper) return std::vector<gfloat>{ 0 };

  std::vector<gfloat> joint_values(j_.num.gripper);

  for (int i = 0; i < j_.num.gripper; i++) {
    joint_values[i] = data->qpos[j_.idx.gripper[i]];
  }

  return joint_values;
}

std::vector<gfloat> get_target_state()
{
  /* Get the state of the gripper target */

  return target_.get_target_m();

  // // old code
  // // target_.end.update();
  // gfloat x = target_.end.x;
  // gfloat y = target_.end.y; // or theta?
  // gfloat z = target_.end.z;

  // std::vector<gfloat> target_joint_values = { x, y, z };

  // return target_joint_values;
}

int get_N() 
{
  return j_.num.per_finger + j_.dim.fixed_first_segment;
}

float get_finger_thickness()
{
  return j_.dim.finger_thickness;
}

std::vector<luke::gfloat> get_stiffnesses()
{
  return j_.dim.joint_stiffness;
}

gfloat get_target_finger_angle()
{
  /* return the target finger angle in radians */

  return target_.end.get_th_rad();
}

float calc_yield_point_load()
{
  /* return the vertical point load to yield the cantilever */

  float M_max = (j_.dim.yield_stress * j_.dim.I) / (0.5 * j_.dim.finger_thickness);
  float F_max = M_max / j_.dim.finger_length;

  return F_max;
}

float get_fingertip_z_height()
{
  /* return the distance from the fingertip to the ground in mm. A negative value
  means the fingertips hit the ground */

  float straight_finger_distance = -Target::base_z_min - target_.base[0];
  float tip_lift = j_.dim.finger_length * (1 - std::cos(target_.end.get_th_rad()));
  float height_above_min = straight_finger_distance + tip_lift;

  return height_above_min + Target::base_z_min;
}

/* ----- environment ----- */

Gripper get_gripper_target()
{
  /* get the target state of the gripper */

  return target_.end;
}

std::vector<std::string> get_objects()
{
  /* get the names of objects in the simulation scene */

  std::vector<std::string> objects;

  for (int i = 0; i < oh_.names.size(); i++) {
    if (oh_.in_use[i]) {
      objects.push_back(oh_.names[i]);
    }
  }
  
  return objects;
}

void reset_object(mjModel* model, mjData* data)
{
  /* reset the live object to its starting position outside the task area */

  oh_.reset_live(model, data);
}

void spawn_object(mjModel* model, mjData* data, std::string name, QPos pose)
{
  /* overload to pass object name not index */

  for (int i = 0; i < oh_.names.size(); i++) {
    if (oh_.names[i] == name and oh_.in_use[i]) {
      spawn_object(model, data, i, pose);
      return;
    }
  }

  throw std::runtime_error("name not found");
}

void spawn_object(mjModel* model, mjData* data, int idx, QPos pose)
{
  /* spawn an object in the simulation with the given pose, and always wipes qvel */

  oh_.spawn_object(model, data, idx, pose);
}

QPos get_object_qpos(mjModel* model, mjData* data)
{
  /* returns the position of the live object in the simulation */

  if (oh_.live_object == -1) {
    QPos empty;
    return empty;
    throw std::runtime_error("no live object");
  }

  if (oh_.live_object >= oh_.names.size())
    throw std::runtime_error("live object exceeds number of named objects");

  // // for testing
  // QPos test = get_object_qpos();
  // printf("qpos is xyz (%.3f, %.3f, %.3f)\n", test.x, test.y, test.z);

  // old, when qpos was updated
  // return oh_.qpos[oh_.live_object];

  return oh_.get_live_qpos(model, data);
}

Forces get_object_forces(const mjModel* model, mjData* data)
{
  /* get the contact forces on the live object */

  // use the faster version of the extract_forces() function
  return oh_.extract_forces(model, data);
}

Forces_faster get_object_forces_faster(const mjModel* model, mjData* data)
{
  /* get the contact forces on the live object */

  // use the faster version of the extract_forces() function
  return oh_.extract_forces_faster(model, data);
}

void set_object_colour(mjModel* model, std::vector<float> rgba)
{
  /* set the colour of the main object */

  oh_.set_colour(model, rgba);
}

void set_ground_colour(mjModel* model, std::vector<float> rgba)
{
  /* randomise the colour of the ground */

  oh_.set_ground_colour(model, rgba);
}

void randomise_all_colours(mjModel* model, std::shared_ptr<std::default_random_engine> generator)
{
  /* randomise the colour of every object but not the ground*/

  oh_.randomise_all_colours(model, generator);
}

void default_colours(mjModel* model)
{
  /* restore colours to default values */

  oh_.default_colours(model);

  std::vector<float> rgba_default { 0.5, 0.5, 0.5, 1.0 };
  set_finger_colour(model, rgba_default, 1);
  set_finger_colour(model, rgba_default, 2);
  set_finger_colour(model, rgba_default, 3);
  set_finger_colour(model, rgba_default, 4); // 4 means palm
}

void set_finger_colour(mjModel* model, std::vector<float> rgba, int finger_num)
{
  /* set the segmented finger all to one colour, finger_num = 1,2,3, or 4 (4 means palm) */

  if (rgba.size() != 3 and rgba.size() != 4) {
    throw std::runtime_error("set_finger_colour() not given a rgba vector of size 3 or 4");
  }

  // make a pointer to a vector so we can flexibly swap between different fingers
  std::vector<int>* fptr;

  // assign this pointer to one of the following options
  if (finger_num == 1) fptr = &j_.geom_idx.finger1;
  else if (finger_num == 2) fptr = &j_.geom_idx.finger2;
  else if (finger_num == 3) fptr = &j_.geom_idx.finger3;
  else if (finger_num == 4) fptr = &j_.geom_idx.palm;
  else {
    throw std::runtime_error("set_finger_colour() expects finger_num equal to either 1,2,3 or 4 (4 is palm)");
  }

  // loop through the vector we assigned and update the colour
  for (int i : *fptr) {
    model->geom_rgba[i * 4 + 0] = rgba[0];
    model->geom_rgba[i * 4 + 1] = rgba[1];
    model->geom_rgba[i * 4 + 2] = rgba[2];

    // if an a value is given, set this too
    if (rgba.size() == 4)
      model->geom_rgba[i * 4 + 3] = rgba[3];
  }
}

/* ----- misc ----- */

int last_action_robot()
{
  /* which robot was the last robot used for a change in target.
        0 = none,
        1 = gripper,
        2 = panda
  */

  return target_.last_robot;
}

bool is_sim_unstable(mjModel* model, mjData* data)
{
  /* detect if the simulation has become unstable */

  if (data->warning[mjWARN_BADQACC].number > 0) {
    return true;
  }

  return false;
}

void print_stiffnesses()
{
  print_vec(get_stiffnesses(), "Joint stiffnesses");
}

} // namespace luke